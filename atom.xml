<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>静默的魔法书</title>
  
  <subtitle>零</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhz.gift/"/>
  <updated>2018-01-30T14:37:52.602Z</updated>
  <id>http://www.zhz.gift/</id>
  
  <author>
    <name>Hans Chung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HikariCP 配置说明</title>
    <link href="http://www.zhz.gift/2018/01/30/HikariCP%20%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
    <id>http://www.zhz.gift/2018/01/30/HikariCP 配置说明/</id>
    <published>2018-01-29T16:07:42.000Z</published>
    <updated>2018-01-30T14:37:52.602Z</updated>
    
    <content type="html"><![CDATA[<p>Fast, simple, reliable. HikariCP is a “zero-overhead” production ready JDBC connection pool. At roughly 130Kb, the library is very light.</p><a id="more"></a><p><a href="https://github.com/darkleave/HikariCP" target="_blank" rel="external">官网连接</a></p><h2 id="必要配置"><a href="#必要配置" class="headerlink" title="必要配置"></a>必要配置</h2><ol><li>dataSourceClassName 数据源驱动名</li><li>jdbcUrl jdbc数据库连接</li><li>username 用户名</li><li>password 密码</li></ol><p>其中dataSourceClassName和jdbcUrl二选一，当使用比较老版本的驱动时，需要同时设置jdbcUrl和driverClassName，dataSourceClassName则不用进行设置</p><h2 id="可选配置"><a href="#可选配置" class="headerlink" title="可选配置"></a>可选配置</h2><ol><li><p>常用属性</p><ul><li>connectionTimeout 连接超时时间,最小时间为250 ms，默认为30000ms(30秒)</li><li><p>idleTimeout 空闲超时时间，这个属性用来控制空闲连接允许保留在连接池中的最大时间，这个属性只有在minimumIdle（最小空闲连接数）小于maximumPoolSize(最大连接数)时才会生效,空闲连接断开会有15s-30s的延迟变动时间.在这个超时时间之前空闲连接永远不会断开,当连接池达到minimumIdle,连接将永远不会断开，即使处于闲置状态.值为0表示空闲连接将永远不会从连接池中移除，最小值为10000ms （10s),默认值为600000(10min)</p></li><li><p>maxLifetime 最大生命周期.这个属性用来控制连接池中连接的最大生命周期,一个使用中的连接永远不会被断开,只有当它处于关闭状态然后才会被移除.推荐设置比任何数据库或基础设施规定的连接时间限制少至少30秒。 值为0表示没有最大寿命（无限寿命）， 默认：1800000（30分钟）,由于HikariCP的housekeeper默认每30s运行一次,以维护minimumIdle最小空闲连接数，它可能添加新连接或者断开空闲连接，所以你必须设置maxLifetime属性比（mysql)wait_timeout时间少一些来避免 broken connection / exceptions.意思就是说比如mysql wait_timeout为10min,此时有一个连接由于达到超时时间，mysql主动断开了连接，而HakariCP仍然持有此连接，如果再使用此连接去请求数据库则会发生异常,设置maxLifetime最大生命周期比wait_timeout少30s后,就能确保再housekeeper运行期间提前断开此连接，避免发生异常.</p></li><li>connectionTestQuery 连接测试查询,如果你的驱动支持jdbc4，则不需要设置此属性，这个属性是为那些不支持Connection.isValid() API的古董级驱动准备的，这是一个查询，用来确保所有请求得到的连接都是alive有效的，尝试不设置这个属性运行连接池，如果你的驱动不支持jdbc4，HikariCP会有错误日志提示.Default:None</li><li>minimumIdle 最小空闲连接，当空闲连接小于这个值并且总连接数小于maximumPoolSize（最大连接数)HikariCP会尽可能快速有效率地创建额外的连接，然而为了最大限度地提高性能和响应能力，不建议设置这个值，而是用固定大小的连接池取代.Default:与maximumPoolSize相同</li><li>maximumPoolSize 最大连接池数量，包括使用中和空闲的连接，当达到最大连接池数量时，再尝试获取连接，只能得到connectionTimeout 超时信息.Default:10.</li><li>metricRegistry 度量注册, Default: none <a href="https://www.jianshu.com/p/070f615dfb57" target="_blank" rel="external">参考链接</a></li><li>healthCheckRegistry 健康检查注册  Default: none</li><li>poolName 连接池名字,一般用于日志输出 Default: auto-generated</li></ul></li><li>不常使用<ul><li>initializationFailTimeout 初始化失败超时时间 Default: 1</li><li>isolateInternalQueries 是否隔离默认查询 Default: 1</li><li>allowPoolSuspension 是否允许连接池暂停 Default: false</li><li>readOnly 连接是否只读 Default: false</li><li>registerMbeans 是否注册JMX Management Beans Default: false</li><li>catalog 目录服务</li><li>connectionInitSql 连接初始化sql Default: none</li><li>driverClassName 驱动名称  Default: none</li><li>transactionIsolation 事务隔离 Default: driver default</li><li>validationTimeout 验证超时时间 Default: 5000 </li><li>leakDetectionThreshold 最低发现阈值 Default: 0</li><li>dataSource 数据源 Default: none</li><li>schema 架构  Default: driver default</li><li>threadFactory 线程工厂 Default: none </li><li>scheduledExecutor 计划执行器 Default: none</li></ul></li></ol><h2 id="Statement-Cache"><a href="#Statement-Cache" class="headerlink" title="Statement Cache"></a>Statement Cache</h2><p>Many connection pools, including Apache DBCP, Vibur, c3p0 and others offer PreparedStatement caching. HikariCP does not. Why?<br>许多连接池，包括Aache DBCP,Vibur,c3p0 等都是提供PreparedStatement caching.HikariCP并不这样做，为什么？</p><p>At the connection pool layer PreparedStatements can only be cached per connection. If your application has 250 commonly executed queries and a pool of 20 connections you are asking your database to hold on to 5000 query execution plans – and similarly the pool must cache this many PreparedStatements and their related graph of objects.</p><p>在连接池中每个连接只能缓存各自的PreparedStatements对象.如果你的应用有250个要执行的普通查询和一个20个连接的连接池，然后你需要不间断地请求你的数据库去完成一个5000查询的执行计划，显然你的连接池必须缓存这所有的PreparedStatements对象和它们相关联的表对象.</p><p>Most major database JDBC drivers already have a Statement cache that can be configured, including PostgreSQL, Oracle, Derby, MySQL, DB2, and many others. JDBC drivers are in a unique position to exploit database specific features, and nearly all of the caching implementations are capable of sharing execution plans across connections. This means that instead of 5000 statements in memory and associated execution plans, your 250 commonly executed queries result in exactly 250 execution plans in the database. Clever implementations do not even retain PreparedStatement objects in memory at the driver-level but instead merely attach new instances to existing plan IDs.</p><p>许多主流的数据库，它们的jdbc驱动已经有了一个可配置的Statement缓存，包括PostgreSQL, Oracle, Derby, MySQL, DB2等等.JDBC驱动是唯一能利用数据库特定属性的方式，并且近乎所有的缓存实现都可以通过连接共享执行计划.这意味着你的250个普通查询结果在数据库中就是250个执行计划，而不是存储在内存中的5000个statements及其相关联的执行计划.聪明的缓存实现在驱动这一级别并不保持PreparedStatement对象在内存当中，而是为已存在的计划创建新的PreparedStatement实例.</p><p>Using a statement cache at the pooling layer is an anti-pattern, and will negatively impact your application performance compared to driver-provided caches.</p><p>在连接池层使用statement缓存是一个反面教材,并且相较驱动提供的缓存会对你的应用性能造成更大的消极影响.</p><h2 id="Log-Statement-Text-Slow-Query-Logging"><a href="#Log-Statement-Text-Slow-Query-Logging" class="headerlink" title="Log Statement Text / Slow Query Logging"></a>Log Statement Text / Slow Query Logging</h2><p>Like Statement caching, most major database vendors support statement logging through properties of their own driver. This includes Oracle, MySQL, Derby, MSSQL, and others. Some even support slow query logging. For those few databases that do not support it, several options are available. We have received a report that p6spy works well, and also note the availability of log4jdbc and jdbcdslog-exp.</p><p>就像Statement缓存，许多主流数据库供应商支持通过它们驱动的属性配置来添加statement logging的日志功能.这些数据库包括racle, MySQL, Derby, MSSQL等等.一些甚至支持<a href="https://baike.baidu.com/item/%E6%85%A2%E6%9F%A5%E8%AF%A2/9200910?fr=aladdin" target="_blank" rel="external">慢查询</a>日志记录功能.对于那些少数不支持的数据库,还有许多可用的其它方式.比如,p6spy,log4jdbc以及jdbcdslog-exp等等.</p><p><a href="https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration" target="_blank" rel="external">mysql推荐配置</a><br><a href="http://blog.csdn.net/suwu150/article/details/52745055" target="_blank" rel="external">Statement和PreparedStatement对象的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Fast, simple, reliable. HikariCP is a “zero-overhead” production ready JDBC connection pool. At roughly 130Kb, the library is very light.&lt;/p&gt;
    
    </summary>
    
    
      <category term="pool" scheme="http://www.zhz.gift/tags/pool/"/>
    
  </entry>
  
  <entry>
    <title>git 换行符LF与CRLF转换问题</title>
    <link href="http://www.zhz.gift/2018/01/29/git%20%E6%8D%A2%E8%A1%8C%E7%AC%A6LF%E4%B8%8ECRLF%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
    <id>http://www.zhz.gift/2018/01/29/git 换行符LF与CRLF转换问题/</id>
    <published>2018-01-28T16:07:42.000Z</published>
    <updated>2018-01-29T14:04:28.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>在各操作系统下，文本文件所使用的换行符是不一样的。UNIX/Linux 使用的是 0x0A（LF），早期的 Mac OS 使用的是0x0D（CR），后来的 OS X 在更换内核后与 UNIX 保持一致了。但 DOS/Windows 一直使用 0x0D0A（CRLF）作为换行符。Git提供了一个“换行符自动转换”功能。这个功能默认处于“自动模式”，当你在签出文件时，它试图将 UNIX 换行符（LF）替换为 Windows 的换行符（CRLF）；当你在提交文件时，它又试图将 CRLF 替换为 LF。Git 的“换行符自动转换”功能听起来似乎很智能、很贴心，因为它试图一方面保持仓库内文件的一致性（UNIX 风格），一方面又保证本地文件的兼容性（Windows 风格）。但遗憾的是，这个功能是有 bug 的，而且在短期内都不太可能会修正。</p><a id="more"></a><h2 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h2><p>1.Git设置</p><p>git config –global core.autocrlf false<br>git config –global core.safecrlf true<br>含义：<br>AutoCRLF<br><strong>提交时转换为LF，检出时转换为CRLF</strong><br>git config –global core.autocrlf true</p><p><strong>提交时转换为LF，检出时不转换</strong><br>git config –global core.autocrlf input</p><p><strong>提交检出均不转换</strong><br>git config –global core.autocrlf false<br>SafeCRLF<br><strong>拒绝提交包含混合换行符的文件</strong><br>git config –global core.safecrlf true</p><p><strong>允许提交包含混合换行符的文件</strong><br>git config –global core.safecrlf false</p><p><strong>提交包含混合换行符的文件时给出警告</strong><br>git config –global core.safecrlf warn</p><p>一般在开发中为了保持项目换行符转换不出错，将autocrlf设置为false,<br>然后重新clone项目。</p><p>也可以直接修改git全局配置文件，windows配置路径:<br>C:\Users\Administrator.gitconfig</p><pre><code>[filter &quot;lfs&quot;]    required = true    clean = git-lfs clean %f    smudge = git-lfs smudge %f[user]    name = zhonghanzhong[user]    email = yyesnnovv@aliyun.com[credential]    helper = manager[http]    sslVerify = false[core]    autocrlf = false</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;在各操作系统下，文本文件所使用的换行符是不一样的。UNIX/Linux 使用的是 0x0A（LF），早期的 Mac OS 使用的是0x0D（CR），后来的 OS X 在更换内核后与 UNIX 保持一致了。但 DOS/Windows 一直使用 0x0D0A（CRLF）作为换行符。Git提供了一个“换行符自动转换”功能。这个功能默认处于“自动模式”，当你在签出文件时，它试图将 UNIX 换行符（LF）替换为 Windows 的换行符（CRLF）；当你在提交文件时，它又试图将 CRLF 替换为 LF。Git 的“换行符自动转换”功能听起来似乎很智能、很贴心，因为它试图一方面保持仓库内文件的一致性（UNIX 风格），一方面又保证本地文件的兼容性（Windows 风格）。但遗憾的是，这个功能是有 bug 的，而且在短期内都不太可能会修正。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevelopNote" scheme="http://www.zhz.gift/tags/DevelopNote/"/>
    
      <category term="git" scheme="http://www.zhz.gift/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>jooq介绍</title>
    <link href="http://www.zhz.gift/2018/01/15/jooq%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.zhz.gift/2018/01/15/jooq介绍/</id>
    <published>2018-01-14T16:07:42.000Z</published>
    <updated>2018-01-15T14:05:22.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jooq是什么"><a href="#jooq是什么" class="headerlink" title="jooq是什么"></a>jooq是什么</h2><p>jOOQ（Java Object Oriented Querying，即面向Java对象查询）是基于Java访问关系型数据库的工具包，轻量，简单，并且足够灵活，可以轻松的使用Java面向对象语法来实现各种复杂的sql;是一个高效地合并了复杂SQL、类型安全、源码生成、ActiveRecord、存储过程以及高级数据类型的Java API的类库.</p><a id="more"></a><h2 id="jooq的特点"><a href="#jooq的特点" class="headerlink" title="jooq的特点"></a>jooq的特点</h2><ol><li><p>类型安全(TypeSafe SQL)<br>jooq使用内部的DSL(domain specific language领域专用语言)对sql进行模块化，并且使用java编译器去编译你的sql语法，元数据以及数据类型.</p></li><li><p>映射代码生成<br>jooq可以从你的数据库元数据生成对应的java映射类，生成的实体类按照数据库字段以驼峰命名法重新命名，同时用户可以通过继承实体类的方式来添加自定义属性及方法.</p></li><li><p>ActiveRecords<br>我们jooq通过代码生成器生成的ActiveReocrds可以直接对POJO(Plain Old Java Object)映射对象进行CRUD(Create Retrieve Update Delete)操作</p></li><li><p>多架构(多模式Schema)<br>jooq允许你在运行时环境动态配置数据库模式和表并且支持行级别的安全性,即通过不同的jooq Configuration配置得到对应的DSLContext上下文再对数据库进行CRUD操作.</p></li><li><p>标准化<br>jooq可以通过配置数据库方言来支持不同的数据库:mysql,oracle等等,比如通过spring配置spring.jooq.sql-dialect = mysql 来支持mysql数据库</p></li><li><p>查询生命周期<br>jooq通过一些接口开放SQL生成的生命周期，包括日志，事务处理，id生成，sql转换等等。</p></li><li><p>存储过程<br>jooq允许你在模块化sql语句中嵌入存储过程调用.</p></li><li><p>强大的Fluent API和完善文档,使用方便流畅</p></li></ol><p><strong>参考链接</strong><br><a href="https://www.jianshu.com/p/46164f9ba53c" target="_blank" rel="external">https://www.jianshu.com/p/46164f9ba53c</a><br><a href="https://www.jooq.org/" target="_blank" rel="external">https://www.jooq.org/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;jooq是什么&quot;&gt;&lt;a href=&quot;#jooq是什么&quot; class=&quot;headerlink&quot; title=&quot;jooq是什么&quot;&gt;&lt;/a&gt;jooq是什么&lt;/h2&gt;&lt;p&gt;jOOQ（Java Object Oriented Querying，即面向Java对象查询）是基于Java访问关系型数据库的工具包，轻量，简单，并且足够灵活，可以轻松的使用Java面向对象语法来实现各种复杂的sql;是一个高效地合并了复杂SQL、类型安全、源码生成、ActiveRecord、存储过程以及高级数据类型的Java API的类库.&lt;/p&gt;
    
    </summary>
    
    
      <category term="jooq" scheme="http://www.zhz.gift/tags/jooq/"/>
    
  </entry>
  
  <entry>
    <title>Pom.xml详解</title>
    <link href="http://www.zhz.gift/2018/01/11/Pom.xml%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.zhz.gift/2018/01/11/Pom.xml详解/</id>
    <published>2018-01-10T16:07:42.000Z</published>
    <updated>2018-01-11T15:29:33.547Z</updated>
    
    <content type="html"><![CDATA[<p>Maven pom.xml详细配置说明</p><a id="more"></a><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>pom中节点如下分布</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0            http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;!-- 基本配置 --&gt;    &lt;groupId&gt;...&lt;/groupId&gt;    &lt;artifactId&gt;...&lt;/artifactId&gt;    &lt;version&gt;...&lt;/version&gt;    &lt;packaging&gt;...&lt;/packaging&gt;    &lt;!-- 依赖配置 --&gt;    &lt;dependencies&gt;...&lt;/dependencies&gt;    &lt;parent&gt;...&lt;/parent&gt;    &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;    &lt;modules&gt;...&lt;/modules&gt;    &lt;properties&gt;...&lt;/properties&gt;    &lt;!-- 构建配置 --&gt;    &lt;build&gt;...&lt;/build&gt;    &lt;reporting&gt;...&lt;/reporting&gt;    &lt;!-- 项目信息 --&gt;    &lt;name&gt;...&lt;/name&gt;    &lt;description&gt;...&lt;/description&gt;    &lt;url&gt;...&lt;/url&gt;    &lt;inceptionYear&gt;...&lt;/inceptionYear&gt;    &lt;licenses&gt;...&lt;/licenses&gt;    &lt;organization&gt;...&lt;/organization&gt;    &lt;developers&gt;...&lt;/developers&gt;    &lt;contributors&gt;...&lt;/contributors&gt;    &lt;!-- 环境设置 --&gt;    &lt;issueManagement&gt;...&lt;/issueManagement&gt;    &lt;ciManagement&gt;...&lt;/ciManagement&gt;    &lt;mailingLists&gt;...&lt;/mailingLists&gt;    &lt;scm&gt;...&lt;/scm&gt;    &lt;prerequisites&gt;...&lt;/prerequisites&gt;    &lt;repositories&gt;...&lt;/repositories&gt;    &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;    &lt;distributionManagement&gt;...&lt;/distributionManagement&gt;    &lt;profiles&gt;...&lt;/profiles&gt;&lt;/project&gt;</code></pre><h2 id="2-基本配置"><a href="#2-基本配置" class="headerlink" title="2.基本配置"></a>2.基本配置</h2><ul><li>modelVersion：pom模型版本，maven2和3只能为4.0.0</li><li>groupId：组ID，maven用于定位</li><li>artifactId：在组中的唯一ID用于定位</li><li>version：项目版本</li><li>packaging：项目打包方式，有以下值：pom, jar, maven-plugin, ejb, war, ear, rar, par</li></ul><h2 id="3-依赖配置"><a href="#3-依赖配置" class="headerlink" title="3.依赖配置"></a>3.依赖配置</h2><p>parent</p><p>用于确定父项目的坐标。</p><pre><code>&lt;parent&gt;    &lt;groupId&gt;com.learnPro&lt;/groupId&gt;    &lt;artifactId&gt;SIP-parent&lt;/artifactId&gt;    &lt;relativePath&gt;&lt;/relativePath&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;</code></pre><ul><li>groupId：父项目的构件标识符</li><li>artifactId：父项目的唯一标识符</li><li>relativePath：Maven首先在当前项目的找父项目的pom，然后在文件系统的这个位置（relativePath），然后在本地仓库，再在远程仓库找。</li><li>version：父项目的版本</li></ul><p>modules</p><p>有些maven项目会做成多模块的，这个标签用于指定当前项目所包含的所有模块。之后对这个项目进行的maven操作，会让所有子模块也进行相同操作。</p><pre><code>&lt;modules&gt;   &lt;module&gt;com-a&lt;/module&gt;   &lt;module&gt;com-b&lt;/module&gt;   &lt;module&gt;com-c&lt;/module&gt;&lt;/modules&gt;</code></pre><p>properties</p><p>用于定义pom常量</p><pre><code>&lt;properties&gt;    &lt;java.version&gt;1.7&lt;/java.version&gt;&lt;/properties&gt;</code></pre><p>上面这个常量可以在pom文件的任意地方通过${java.version}来引用</p><p>dependencies</p><p>项目相关依赖配置，如果在父项目写的依赖，会被子项目引用，一般父项目会将子项目公用的依赖引入（将在之后详细讲解）</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>这边依赖和中央仓库中的一致，就可以引入对应的jar</p><p>dependencyManagement</p><p>配置写法同dependencies</p><pre><code>&lt;dependencyManagement&gt;    &lt;dependencies&gt;    .....    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code></pre><p>在父模块中定义后，子模块不会直接使用对应依赖，但是在使用相同依赖的时候可以不加版本号：</p><pre><code>父项目：&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;子项目：&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>这样的好处是，父项目统一了版本，而且子项目可以在需要的时候才引用对应的依赖    </p><h2 id="4-构建配置"><a href="#4-构建配置" class="headerlink" title="4.构建配置"></a>4.构建配置</h2><p>build</p><p>用于配置项目构建相关信息</p><pre><code>&lt;build&gt;        &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;        &lt;sourceDirectory/&gt;        &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt;      &lt;scriptSourceDirectory/&gt;      &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;      &lt;testSourceDirectory/&gt;      &lt;!--被编译过的应用程序class文件存放的目录。--&gt;      &lt;outputDirectory/&gt;      &lt;!--被编译过的测试class文件存放的目录。--&gt;      &lt;testOutputDirectory/&gt;      &lt;!--使用来自该项目的一系列构建扩展--&gt;      &lt;extensions&gt;       &lt;!--描述使用到的构建扩展。--&gt;       &lt;extension&gt;        &lt;!--构建扩展的groupId--&gt;        &lt;groupId/&gt;        &lt;!--构建扩展的artifactId--&gt;        &lt;artifactId/&gt;        &lt;!--构建扩展的版本--&gt;        &lt;version/&gt;       &lt;/extension&gt;      &lt;/extensions&gt;      &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt;      &lt;defaultGoal/&gt;      &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt;      &lt;resources&gt;       &lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt;       &lt;resource&gt;        &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt;        &lt;targetPath/&gt;        &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt;        &lt;filtering/&gt;        &lt;!--描述存放资源的目录，该路径相对POM路径--&gt;        &lt;directory/&gt;        &lt;!--包含的模式列表，例如**/*.xml.--&gt;        &lt;includes/&gt;        &lt;!--排除的模式列表，例如**/*.xml--&gt;        &lt;excludes/&gt;       &lt;/resource&gt;      &lt;/resources&gt;      &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt;      &lt;testResources&gt;       &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt;       &lt;testResource&gt;        &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;       &lt;/testResource&gt;      &lt;/testResources&gt;      &lt;!--构建产生的所有文件存放的目录--&gt;      &lt;directory/&gt;      &lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。--&gt;      &lt;finalName/&gt;      &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt;      &lt;filters/&gt;      &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt;      &lt;pluginManagement&gt;       &lt;!--使用的插件列表 。--&gt;       &lt;plugins&gt;        &lt;!--plugin元素包含描述插件所需要的信息。--&gt;        &lt;plugin&gt;         &lt;!--插件在仓库里的group ID--&gt;         &lt;groupId/&gt;         &lt;!--插件在仓库里的artifact ID--&gt;         &lt;artifactId/&gt;         &lt;!--被使用的插件的版本（或版本范围）--&gt;         &lt;version/&gt;         &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt;         &lt;extensions/&gt;         &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt;         &lt;executions&gt;          &lt;!--execution元素包含了插件执行需要的信息--&gt;          &lt;execution&gt;           &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt;           &lt;id/&gt;           &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt;           &lt;phase/&gt;           &lt;!--配置的执行目标--&gt;           &lt;goals/&gt;           &lt;!--配置是否被传播到子POM--&gt;           &lt;inherited/&gt;           &lt;!--作为DOM对象的配置--&gt;           &lt;configuration/&gt;          &lt;/execution&gt;         &lt;/executions&gt;         &lt;!--项目引入插件所需要的额外依赖--&gt;         &lt;dependencies&gt;          &lt;!--参见dependencies/dependency元素--&gt;          &lt;dependency&gt;           ......          &lt;/dependency&gt;         &lt;/dependencies&gt;              &lt;!--任何配置是否被传播到子项目--&gt;         &lt;inherited/&gt;         &lt;!--作为DOM对象的配置--&gt;         &lt;configuration/&gt;        &lt;/plugin&gt;       &lt;/plugins&gt;      &lt;/pluginManagement&gt;      &lt;!--使用的插件列表--&gt;      &lt;plugins&gt;       &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;       &lt;plugin&gt;        &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;        &lt;executions&gt;         &lt;execution&gt;          &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;         &lt;/execution&gt;        &lt;/executions&gt;        &lt;dependencies&gt;         &lt;!--参见dependencies/dependency元素--&gt;         &lt;dependency&gt;          ......         &lt;/dependency&gt;        &lt;/dependencies&gt;        &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;       &lt;/plugin&gt;      &lt;/plugins&gt;     &lt;/build&gt;</code></pre><p>reporting</p><p>该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。</p><pre><code>&lt;reporting&gt;      &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt;      &lt;excludeDefaults/&gt;      &lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。--&gt;      &lt;outputDirectory/&gt;      &lt;!--使用的报表插件和他们的配置。--&gt;      &lt;plugins&gt;       &lt;!--plugin元素包含描述报表插件需要的信息--&gt;       &lt;plugin&gt;        &lt;!--报表插件在仓库里的group ID--&gt;        &lt;groupId/&gt;        &lt;!--报表插件在仓库里的artifact ID--&gt;        &lt;artifactId/&gt;        &lt;!--被使用的报表插件的版本（或版本范围）--&gt;        &lt;version/&gt;        &lt;!--任何配置是否被传播到子项目--&gt;        &lt;inherited/&gt;        &lt;!--报表插件的配置--&gt;        &lt;configuration/&gt;        &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt;        &lt;reportSets&gt;         &lt;!--表示报表的一个集合，以及产生该集合的配置--&gt;         &lt;reportSet&gt;          &lt;!--报表集合的唯一标识符，POM继承时用到--&gt;          &lt;id/&gt;          &lt;!--产生报表集合时，被使用的报表的配置--&gt;          &lt;configuration/&gt;          &lt;!--配置是否被继承到子POMs--&gt;          &lt;inherited/&gt;          &lt;!--这个集合里使用到哪些报表--&gt;          &lt;reports/&gt;         &lt;/reportSet&gt;        &lt;/reportSets&gt;       &lt;/plugin&gt;      &lt;/plugins&gt;     &lt;/reporting&gt;</code></pre><h2 id="5-项目信息"><a href="#5-项目信息" class="headerlink" title="5.项目信息"></a>5.项目信息</h2><ul><li>name：给用户提供更为友好的项目名</li><li>description：项目描述，maven文档中保存</li><li>url：主页的URL，maven文档中保存</li><li>inceptionYear：项目创建年份，4位数字。当产生版权信息时需要使用这个值</li><li>licenses：该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。（如下）</li></ul><pre><code>&lt;license&gt;      &lt;!--license用于法律上的名称--&gt;        &lt;name&gt;...&lt;/name&gt;         &lt;!--官方的license正文页面的URL--&gt;        &lt;url&gt;....&lt;/url&gt;    &lt;!--项目分发的主要方式：repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖--&gt;        &lt;distribution&gt;repo&lt;/distribution&gt;         &lt;!--关于license的补充信息--&gt;        &lt;comments&gt;....&lt;/comments&gt;     &lt;/license&gt; </code></pre><ul><li>organization：1.name 组织名 2.url 组织主页url</li><li>developers：项目开发人员列表（如下）</li><li>contributors：项目其他贡献者列表，同developers    </li></ul><pre><code>&lt;developers&gt;  &lt;!--某个开发者信息--&gt;&lt;developer&gt;      &lt;!--开发者的唯一标识符--&gt;    &lt;id&gt;....&lt;/id&gt;      &lt;!--开发者的全名--&gt;    &lt;name&gt;...&lt;/name&gt;      &lt;!--开发者的email--&gt;    &lt;email&gt;...&lt;/email&gt;      &lt;!--开发者的主页--&gt;    &lt;url&gt;...&lt;url/&gt;    &lt;!--开发者在项目中的角色--&gt;    &lt;roles&gt;          &lt;role&gt;Java Dev&lt;/role&gt;          &lt;role&gt;Web UI&lt;/role&gt;      &lt;/roles&gt;     &lt;!--开发者所属组织--&gt;     &lt;organization&gt;sun&lt;/organization&gt;      &lt;!--开发者所属组织的URL--&gt;    &lt;organizationUrl&gt;...&lt;/organizationUrl&gt;      &lt;!--开发者属性，如即时消息如何处理等--&gt;    &lt;properties&gt;        &lt;!-- 和主标签中的properties一样，可以随意定义子标签 --&gt;    &lt;/properties&gt;     &lt;!--开发者所在时区， -11到12范围内的整数。--&gt;     &lt;timezone&gt;-5&lt;/timezone&gt;  &lt;/developer&gt;  &lt;/developers&gt;  </code></pre><h2 id="6-环境设置"><a href="#6-环境设置" class="headerlink" title="6.环境设置"></a>6.环境设置</h2><p>issueManagement</p><p>目的问题管理系统(Bugzilla, Jira, Scarab)的名称和URL</p><pre><code>&lt;issueManagement&gt;    &lt;system&gt;Bugzilla&lt;/system&gt;    &lt;url&gt;http://127.0.0.1/bugzilla/&lt;/url&gt;&lt;/issueManagement&gt;</code></pre><ul><li>system：系统类型</li><li>url：路径    </li></ul><p>ciManagement</p><p>项目的持续集成信息</p><pre><code>&lt;ciManagement&gt;    &lt;system&gt;continuum&lt;/system&gt;    &lt;url&gt;http://127.0.0.1:8080/continuum&lt;/url&gt;    &lt;notifiers&gt;      &lt;notifier&gt;        &lt;type&gt;mail&lt;/type&gt;        &lt;sendOnError&gt;true&lt;/sendOnError&gt;        &lt;sendOnFailure&gt;true&lt;/sendOnFailure&gt;        &lt;sendOnSuccess&gt;false&lt;/sendOnSuccess&gt;        &lt;sendOnWarning&gt;false&lt;/sendOnWarning&gt;        &lt;address&gt;continuum@127.0.0.1&lt;/address&gt;        &lt;configuration&gt;&lt;/configuration&gt;      &lt;/notifier&gt;    &lt;/notifiers&gt;  &lt;/ciManagement&gt;</code></pre><ul><li>system：持续集成系统的名字</li><li>url：持续集成系统的URL</li><li>notifiers：构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） <ul><li>type：通知方式</li><li>sendOnError：错误时是否通知</li><li>sendOnFailure：失败时是否通知</li><li>sendOnSuccess：成功时是否通知</li><li>sendOnWarning：警告时是否通知</li><li>address：通知发送到的地址</li><li>configuration：扩展项      </li></ul></li></ul><p>mailingLists</p><p>项目相关邮件列表信息</p><pre><code>&lt;mailingLists&gt;    &lt;mailingList&gt;      &lt;name&gt;User List&lt;/name&gt;      &lt;subscribe&gt;user-subscribe@127.0.0.1&lt;/subscribe&gt;      &lt;unsubscribe&gt;user-unsubscribe@127.0.0.1&lt;/unsubscribe&gt;      &lt;post&gt;user@127.0.0.1&lt;/post&gt;      &lt;archive&gt;http://127.0.0.1/user/&lt;/archive&gt;      &lt;otherArchives&gt;        &lt;otherArchive&gt;http://base.google.com/base/1/127.0.0.1&lt;/otherArchive&gt;      &lt;/otherArchives&gt;    &lt;/mailingList&gt;    .....  &lt;/mailingLists&gt;</code></pre><ul><li>subscribe, unsubscribe: 订阅邮件（取消订阅）的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建</li><li>archive：浏览邮件信息的URL</li><li>post：接收邮件的地址      </li></ul><p>scm</p><p>允许你配置你的代码库，供Maven web站点和其它插件使用</p><pre><code>&lt;scm&gt;    &lt;connection&gt;scm:svn:http://127.0.0.1/svn/my-project&lt;/connection&gt;    &lt;developerConnection&gt;scm:svn:https://127.0.0.1/svn/my-project&lt;/developerConnection&gt;    &lt;tag&gt;HEAD&lt;/tag&gt;    &lt;url&gt;http://127.0.0.1/websvn/my-project&lt;/url&gt;&lt;/scm&gt;</code></pre><ul><li>connection, developerConnection：这两个表示我们如何连接到maven的版本库。connection只提供读，developerConnection将提供写的请求 <ul><li>写法如：scm:[provider]:[provider_specific]</li><li>如果连接到CVS仓库，可以配置如下：scm:cvs:pserver:127.0.0.1:/cvs/root:my-project</li></ul></li><li>tag：项目标签，默认HEAD</li><li>url：共有仓库路径    </li></ul><p>prerequisites</p><p>项目构建的前提</p><pre><code>&lt;prerequisites&gt;    &lt;maven&gt;2.0.6&lt;/maven&gt;&lt;/prerequisites&gt;</code></pre><p>repositories,pluginRepositories</p><p>依赖和扩展的远程仓库列表，同上篇文章，setting.xml配置中介绍的。</p><pre><code>&lt;repositories&gt;    &lt;repository&gt;      &lt;releases&gt;        &lt;enabled&gt;false&lt;/enabled&gt;        &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;        &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt;      &lt;/releases&gt;      &lt;snapshots&gt;        &lt;enabled&gt;true&lt;/enabled&gt;        &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;        &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt;      &lt;/snapshots&gt;      &lt;id&gt;codehausSnapshots&lt;/id&gt;      &lt;name&gt;Codehaus Snapshots&lt;/name&gt;      &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt;      &lt;layout&gt;default&lt;/layout&gt;    &lt;/repository&gt;  &lt;/repositories&gt;  &lt;pluginRepositories&gt;    ...  &lt;/pluginRepositories&gt;</code></pre><ul><li>releases, snapshots:这是各种构件的策略，release或者snapshot。这两个集合，POM就可以根据独立仓库任意类型的依赖改变策略。如：一个人可能只激活下载snapshot用来开发。</li><li>enable：true或者false，决定仓库是否对于各自的类型激活(release 或者 snapshot)。</li><li>updatePolicy: 这个元素决定更新频率。maven将比较本地pom的时间戳（存储在仓库的maven数据文件中）和远程的. 有以下选择: always, daily (默认), interval:X (x是代表分钟的整型) ， never.</li><li>checksumPolicy：当Maven向仓库部署文件的时候，它也部署了相应的校验和文件。可选的为：ignore，fail，warn，或者不正确的校验和。</li><li>layout：在上面描述仓库的时候，提到他们有统一的布局。Maven 2有它仓库默认布局。然而，Maven 1.x有不同布局。使用这个元素来表明它是default还是legacy。      </li></ul><p>distributionManagement</p><p>它管理的分布在整个构建过程生成的工件和支持文件</p><pre><code>&lt;distributionManagement&gt;    ...    &lt;downloadUrl&gt;http://mojo.codehaus.org/my-project&lt;/downloadUrl&gt;    &lt;status&gt;deployed&lt;/status&gt;&lt;/distributionManagement&gt;</code></pre><ul><li>downloadUrl: 其他pom可以通过此url的仓库抓取组件</li><li>status：给出该构件在远程仓库的状态 <ul><li>none: 默认</li><li>converted: 将被早期Maven 2 POM转换过来</li><li>partner: 这个项目会从合作者仓库同步过来</li><li>deployed: 从Maven 2或3实例部署</li><li>verified: 被核实时正确的和最终的    </li></ul></li></ul><p>Repository</p><p>指定Maven pom从远程下载控件到当前项目的位置和方式，如果snapshotRepository没有被定义则使用repository相关的配置</p><pre><code>&lt;distributionManagement&gt;   &lt;repository&gt;     &lt;uniqueVersion&gt;false&lt;/uniqueVersion&gt;     &lt;id&gt;corp1&lt;/id&gt;     &lt;name&gt;Corporate Repository&lt;/name&gt;     &lt;url&gt;scp://repo/maven2&lt;/url&gt;     &lt;layout&gt;default&lt;/layout&gt;   &lt;/repository&gt;   &lt;snapshotRepository&gt;     &lt;uniqueVersion&gt;true&lt;/uniqueVersion&gt;     &lt;id&gt;propSnap&lt;/id&gt;     &lt;name&gt;Propellors Snapshots&lt;/name&gt;     &lt;url&gt;sftp://propellers.net/maven&lt;/url&gt;     &lt;layout&gt;legacy&lt;/layout&gt;   &lt;/snapshotRepository&gt;   ... &lt;/distributionManagement&gt;</code></pre><ul><li>id, name：仓库的唯一标识</li><li>uniqueVersion：true或false，指明控件部署的时候是否获取独立的版本号。</li><li>url：repository元素的核心。指定位置和部署协议发布控件到仓库。</li><li>layout：布局，default或legacy</li></ul><p>Site Distribution</p><p>多分布存储库,distributionManagement负责定义如何部署项目的网站和文档。</p><pre><code>&lt;distributionManagement&gt;   ...   &lt;site&gt;     &lt;id&gt;mojo.website&lt;/id&gt;     &lt;name&gt;Mojo Website&lt;/name&gt;     &lt;url&gt;scp://beaver.codehaus.org/home/projects/mojo/public_html/&lt;/url&gt;   &lt;/site&gt;   ... &lt;/distributionManagement&gt;</code></pre><ul><li>id, name, url: 这些元素与distributionManagement repository中的相同</li></ul><p>Relocation</p><p>重新部署-项目不是静态的，是活的。他们需要被搬到更合适的地方。如：当你的下个成功的开源项目移到Apache下，重命名为org.apache:my-project:1.0 对你项目更有好处。</p><pre><code>&lt;distributionManagement&gt;    ...    &lt;relocation&gt;      &lt;groupId&gt;org.apache&lt;/groupId&gt;      &lt;artifactId&gt;my-project&lt;/artifactId&gt;      &lt;version&gt;1.0&lt;/version&gt;      &lt;message&gt;We have moved the Project under Apache&lt;/message&gt;    &lt;/relocation&gt;    ... &lt;/distributionManagement&gt;</code></pre><p><strong>原文链接: <a href="http://blog.csdn.net/oDeviloo/article/details/52050277" target="_blank" rel="external">http://blog.csdn.net/oDeviloo/article/details/52050277</a></strong><br><strong>参考官方文档： <a href="http://maven.apache.org/pom.html" target="_blank" rel="external">http://maven.apache.org/pom.html</a></strong>   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Maven pom.xml详细配置说明&lt;/p&gt;
    
    </summary>
    
    
      <category term="Maven" scheme="http://www.zhz.gift/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>setting.xml详解</title>
    <link href="http://www.zhz.gift/2018/01/11/setting.xml%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.zhz.gift/2018/01/11/setting.xml详解/</id>
    <published>2018-01-10T16:07:42.000Z</published>
    <updated>2018-01-11T15:27:17.915Z</updated>
    
    <content type="html"><![CDATA[<p>Maven setting.xml详细配置说明</p><a id="more"></a><h2 id="1-文件概览"><a href="#1-文件概览" class="headerlink" title="1.文件概览"></a>1.文件概览</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0            http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;    &lt;localRepository/&gt;    &lt;interactiveMode/&gt;    &lt;offline/&gt;    &lt;pluginGroups/&gt;    &lt;servers/&gt;    &lt;mirrors/&gt;    &lt;proxies/&gt;    &lt;profiles/&gt;    &lt;activeProfiles/&gt;&lt;/settings&gt;</code></pre><p>通过配置文件中的注释，我们可以看到，有两种配置此文件的方法</p><pre><code>1.用户级别${user.home}/.m2/settings.xml可以通过指令 -s /path/to/user/settings.xml2.全局级别${maven.home}/conf/settings.xml.可以通过指令 -gs /path/to/global/settings.xml</code></pre><h2 id="2-localRepository"><a href="#2-localRepository" class="headerlink" title="2.localRepository"></a>2.localRepository</h2><p>localRepository用于构建系统的本地仓库的路径。<br>默认的值是${user.home}/.m2/repository。</p><pre><code>Default: ${user.home}/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</code></pre><h2 id="3-interactiveMode"><a href="#3-interactiveMode" class="headerlink" title="3.interactiveMode"></a>3.interactiveMode</h2><p>interactiveMode 用于决定maven是否在需要输出的时候提示你，默认true。如果是false，它将使用合理的默认值，或者基于一些设置。</p><h2 id="4-offline"><a href="#4-offline" class="headerlink" title="4.offline"></a>4.offline</h2><p>决定maven是否在构建的时候进行网络传输。<br>默认false，表示联网状态，true为取消联网。<br>在某些情况下设置为true是很有用的，比如jar无法从网上下载等</p><h2 id="5-pluginGroups"><a href="#5-pluginGroups" class="headerlink" title="5.pluginGroups"></a>5.pluginGroups</h2><p>pluginGroups 插件组</p><pre><code>&lt;pluginGroups&gt;    &lt;pluginGroup&gt;org.mortbay.jetty&lt;/pluginGroup&gt; &lt;/pluginGroups&gt;</code></pre><p>这样Maven可以使用简单的命令执行org.morbay.jetty:jetty-maven-plugin:run</p><pre><code>mvn jetty run</code></pre><p>我们同样可以在pom文件中看到相似的配置，只是在这配置了就起到全局的作用，而不用每个项目中pom配置jetty   </p><h2 id="6-proxies"><a href="#6-proxies" class="headerlink" title="6.proxies"></a>6.proxies</h2><p>此项用于设置http代理<br>有时候由于安全问题，需要配置http代理，通过代理服务才能正常访问外部仓库下载资源可以ping repo1.maven.org来访问中央仓库<br>telnet 218.14.227.197 3128 来查看代理地址以及端口是否畅通</p><pre><code>&lt;proxies&gt;    &lt;proxy&gt;      &lt;id&gt;optional&lt;/id&gt;      &lt;active&gt;true&lt;/active&gt;      &lt;protocol&gt;http&lt;/protocol&gt;&lt;!--代理协议--&gt;      &lt;username&gt;proxyuser&lt;/username&gt;      &lt;password&gt;proxypass&lt;/password&gt;      &lt;host&gt;proxy.host.net&lt;/host&gt;      &lt;port&gt;80&lt;/port&gt;     &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;    &lt;/proxy&gt;  &lt;/proxies&gt;</code></pre><ul><li>id：proxy的唯一标识，用来区别proxy元素。</li><li>active：表示是否激活代理，如果配置多个，默认是第一个生效</li><li>username，password：提供连接代理服务器时的认证。</li><li>host，port：主机地址，端口号</li><li>nonProxyHosts：用来表示哪些主机名不需要代理，可以用|来分<br>割多个，此外也支持通配符，<br>如：*.goole.com表示所有以goole.com结尾的都不需要通过代理      </li></ul><h2 id="7-servers"><a href="#7-servers" class="headerlink" title="7.servers"></a>7.servers</h2><p>这是一个认证配置的列表,根据系统中使用的server-id控制。认证配置在maven连接到远程服务时使用。</p><pre><code>&lt;servers&gt;    &lt;!--使用登录方式--&gt;    &lt;server&gt;          &lt;id&gt;deploymentRepo&lt;/id&gt;          &lt;username&gt;repouser&lt;/username&gt;          &lt;password&gt;repopwd&lt;/password&gt;        &lt;/server&gt;        &lt;!-- 使用秘钥认证 --&gt;        &lt;server&gt;          &lt;id&gt;siteServer&lt;/id&gt;          &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;          &lt;passphrase&gt;可空&lt;/passphrase&gt;        &lt;/server&gt;&lt;/servers&gt;</code></pre><h2 id="8-mirrors"><a href="#8-mirrors" class="headerlink" title="8.mirrors"></a>8.mirrors</h2><p>指定镜像仓库位置用于从远程仓库下载资源</p><pre><code>&lt;mirrors&gt;    &lt;mirror&gt;      &lt;id&gt;mirrorId&lt;/id&gt;      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;    &lt;/mirror&gt;&lt;/mirrors&gt;</code></pre><ul><li>id：用于继承和直接查找，唯一</li><li>mirrorOf：镜像所包含的仓库的Id</li><li>name：唯一标识，用于区分镜像站</li><li>url：镜像路径    </li></ul><h2 id="9-profiles"><a href="#9-profiles" class="headerlink" title="9.profiles"></a>9.profiles</h2><ol><li>settings.xml中时意味着该profile是全局的，所以只能配置范围宽泛一点配置信息，比如远程仓库等。而一些比较细致一点的需要定义在项目的pom.xml中。</li><li>profile可以让我们定义一系列的配置信息，然后指定其激活条件。<br>根据每个profile对应不同的激活条件和配置信息，从而达到不同环境使用不同配置。</li><li>例子：通过profile定义jdk1.5以上使用一套配置，jdk1.5以下使用另外一套配置；或者通过操作系统来使用不同的配置信息。</li><li>settings.xml中的信息有repositories、pluginRepositories和properties。定义在properties的值可以在pom.xml中使用。</li></ol><p>Activation</p><pre><code>&lt;profiles&gt;    &lt;profile&gt;              &lt;id&gt;test&lt;/id&gt;              &lt;activation&gt;                 &lt;activeByDefault&gt;false&lt;/activeByDefault&gt;                 &lt;jdk&gt;1.5&lt;/jdk&gt;                 &lt;os&gt;                     &lt;name&gt;Windows XP&lt;/name&gt;                     &lt;family&gt;Windows&lt;/family&gt;                     &lt;arch&gt;x86&lt;/arch&gt;                     &lt;version&gt;5.1.2600&lt;/version&gt;                 &lt;/os&gt;                 &lt;property&gt;                     &lt;name&gt;mavenVersion&lt;/name&gt;                     &lt;value&gt;2.0.3&lt;/value&gt;                 &lt;/property&gt;                 &lt;file&gt;                &lt;exists&gt;${basedir}/file2.properties&lt;/exists&gt;               &lt;missing&gt;${basedir}/file1.properties&lt;/missing&gt;                &lt;/file&gt;             &lt;/activation&gt;         &lt;/profile&gt;&lt;/profiles&gt;</code></pre><ul><li>jdk：检测到对应jdk版本就激活</li><li>os：针对不同操作系统</li><li>property：当maven检测到property（pom中如${name}这样的）profile将被激活</li><li>file：如果存在文件，激活，不存在文件激活    </li></ul><p>通过以下命令查看哪些profile将生效</p><pre><code>mvn help:active-profiles</code></pre><p>properites</p><p>Maven的属性是值占位符，就像Ant中的一样。如果X是一个属性的话，在POM中可以使用${X}来进行任意地方的访问。他们来自于五种不同的风格，所有都可以从settings.xml文件中访问到。</p><pre><code>1. env.x：“env.”前缀会返回当前的环境变量。如${env.PATH}就是使用了$path环境变量（windosws中的%PATH%）。2. project.x：一个点“.”分割的路径，在POM中就是相关的元素的值。例如：&lt;project&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt;就可以通过${project.version}来访问。3. settings.x：一个点“.”分割的路径，在settings.xml中就是相对应的元素的值，例如：&lt;settings&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/settings&gt;就可以通过${settings.offline}来访问。4. Java系统属性：通过java.lang.System.getProperties()来访问的属性都可以像POM中的属性一样访问，例如：${java.home}</code></pre><ol><li><p>x：被<properties>或者外部文件定义的属性，值可以这样访问${someVar}    </properties></p> <profiles><br>     <profile><br>       …<br>       <properties><br>         <user.install>${user.home}/our-project</user.install><br>       </properties><br>       …<br>     </profile><br>  </profiles></li></ol><p>上面这个profile如果被激活，那么在pom中${user.install}就可以被访问了。</p><p>Repositories</p><p>Repositories是远程项目集合maven用来移植到本地仓库用于构建系统。如果来自本地仓库，Maven调用它的插件和依赖关系。不同的远程仓库可能包含不同的项目，当profile被激活，他们就会需找匹配的release或者snapshot构件。</p><pre><code>&lt;profiles&gt;    &lt;profile&gt;      ...      &lt;repositories&gt;        &lt;repository&gt;          &lt;id&gt;codehausSnapshots&lt;/id&gt;          &lt;name&gt;Codehaus Snapshots&lt;/name&gt;          &lt;releases&gt;            &lt;enabled&gt;false&lt;/enabled&gt;            &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;            &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt;          &lt;/releases&gt;          &lt;snapshots&gt;            &lt;enabled&gt;true&lt;/enabled&gt;            &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;            &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt;          &lt;/snapshots&gt;          &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt;          &lt;layout&gt;default&lt;/layout&gt;        &lt;/repository&gt;      &lt;/repositories&gt;      &lt;pluginRepositories&gt;        ...      &lt;/pluginRepositories&gt;      ...    &lt;/profile&gt;  &lt;/profiles&gt;</code></pre><ol><li>releases，snapshots：这是各种构件的策略，release或者snapshot。这两个集合，POM就可以根据独立仓库任意类型的依赖改变策略。如：一个人可能只激活下载snapshot用来开发。</li><li>enable：true或者false，决定仓库是否对于各自的类型激活(release 或者 snapshot)。</li><li>updatePolicy: 这个元素决定更新频率。maven将比较本地pom的时间戳（存储在仓库的maven数据文件中）和远程的. 有以下选择: always, daily (默认), interval:X (x是代表分钟的整型) ， never.</li><li>checksumPolicy：当Maven向仓库部署文件的时候，它也部署了相应的校验和文件。可选的为：ignore，fail，warn，或者不正确的校验和。</li><li>layout：在上面描述仓库的时候，提到他们有统一的布局。Maven 2有它仓库默认布局。然而，Maven 1.x有不同布局。使用这个元素来表明它是default还是legacy。      </li></ol><h2 id="10-activeProfiles"><a href="#10-activeProfiles" class="headerlink" title="10.activeProfiles"></a>10.activeProfiles</h2><pre><code>&lt;activeProfiles&gt;    &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt;    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;&lt;/activeProfiles&gt;</code></pre><p>每个activeProfile元素对应一个profile id的值，任何profile id被定义到activeProfile的profile将被激活。</p><p><strong>原文:<a href="http://blog.csdn.net/odeviloo/article/details/51999878" target="_blank" rel="external">http://blog.csdn.net/odeviloo/article/details/51999878</a></strong></p><p><strong>参考：<a href="http://maven.apache.org/settings.html" target="_blank" rel="external">http://maven.apache.org/settings.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Maven setting.xml详细配置说明&lt;/p&gt;
    
    </summary>
    
    
      <category term="Maven" scheme="http://www.zhz.gift/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>jooq基本操作介绍</title>
    <link href="http://www.zhz.gift/2018/01/09/jooq%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.zhz.gift/2018/01/09/jooq基本操作介绍/</id>
    <published>2018-01-08T16:07:42.000Z</published>
    <updated>2018-01-09T13:45:00.293Z</updated>
    
    <content type="html"><![CDATA[<p><strong>jooq基本操作介绍</strong></p><a id="more"></a><h2 id="1-1jooq-select查询"><a href="#1-1jooq-select查询" class="headerlink" title="1.1jooq select查询"></a>1.1jooq select查询</h2><p>select方法接受一个SelectField查询字段集合,org.jooq.Field可以通过<br>生成的任意jooq.tables.*(eg:AudienceItem extends TableImpl<audienceitemrecord>)的Fields方法获取该Table的所有Field字段或者通过该Table的公共成员变量获取部分字段(eg: AUDIENCE_ITEM.ID).</audienceitemrecord></p><p>select方法返回一个<strong>SelectSelectStep</strong><record> 查询步骤对象,一般通过该对象调用from方法完成接下来的表拼接.eg:.from(AUDIENCE_OBJECT).</record></p><p>from方法接受一个TableLike&lt;?&gt;对象，该对象可以是表也可以是视图,最后返回一个<strong>SelectJoinStep</strong><r>对象.</r></p><p>SelectJoinStep对象继承自<strong>SelectWhereStep</strong>对象,通过该对象我们既可以直接后接where方法条件，也可以通过SelectJoinStep对象的join,innerjoin等方法继续关联表进行查询.</p><p>SelectJoinStep对象调用join等方法后(eg:.leftJoin(AUDIENCE_ITEM))返回SelectJoinPartitionByStep<r>对象,该对象继承自<strong>SelectOnStep</strong>对象.</r></p><p><strong>SelectOnStep</strong>对象的主要方法是on,通过on方法来完成join之后的条件拼装(eg:.on(AUDIENCE_OBJECT.ITEM_ID.eq(AUDIENCE_ITEM.ID)),调用完成之后返回SelectOnConditionStep<r>对象.</r></p><p>通过<strong>SelectOnConditionStep</strong><r>对象,可以继续接join,where或者直接调用fetch方法结束sql拼接.</r></p><p>fetch方法返回一个泛型结果集Result<r>,一般通过该结果集的into方法直接转化得到实体列表,具体实例如下:</r></p><pre><code>DSLContext dsl = DSL.using(configuration);dsl.select(Fields.start().add(AUDIENCE_ITEM).end())                .from(AUDIENCE_OBJECT).leftJoin(AUDIENCE_ITEM)                .on(AUDIENCE_OBJECT.ITEM_ID.eq(AUDIENCE_ITEM.ID).and(AUDIENCE_OBJECT.BUSINESS_TYPE.eq(businessType)))                .where(AUDIENCE_OBJECT.BUSINESS_ID.eq(id).and(AUDIENCE_ITEM.ID.isNotNull())).fetch()                .into(AudienceItem.class)</code></pre><p>另:on方法和where方法都是接受一个Condition可变数组为入参,Condition条件对象可由TableImpl对象的TableField字段调用and,eq等条件方法得到.</p><h2 id="1-2-使用DSLContext进行新增-修改-删除"><a href="#1-2-使用DSLContext进行新增-修改-删除" class="headerlink" title="1.2 使用DSLContext进行新增,修改,删除"></a>1.2 使用DSLContext进行新增,修改,删除</h2><pre><code>//新增DSL.using(conf).insertInto(AUDIENCE_OBJECT,AUDIENCE_OBJECT.ID).values(&quot;1&quot;).execute();//更新        DSL.using(conf).update(AUDIENCE_OBJECT).set(AUDIENCE_OBJECT.BUSINESS_ID, AUDIENCE_OBJECT.BUSINESS_ID.add(1)).execute();//删除        DSL.using(conf).delete(AUDIENCE_OBJECT).where(AUDIENCE_OBJECT.BUSINESS_ID.eq(&quot;1&quot;)).execute();</code></pre><h2 id="2-1-使用UpdatableRecord完成新增-修改-删除"><a href="#2-1-使用UpdatableRecord完成新增-修改-删除" class="headerlink" title="2.1 使用UpdatableRecord完成新增,修改,删除"></a>2.1 使用UpdatableRecord完成新增,修改,删除</h2><p>jooq的新增，修改，删除方法都可以通过<strong>UpdatableRecord</strong>对象完成,示例如下:</p><pre><code>DSLContext dsl = DSL.using(conf);UpdatableRecord r = (UpdatableRecord) dsl.newRecord(AUDIENCE_OBJECT, objects.get(0));        //只有不为空的才进行更新        int size = r.size();        for (int i = 0; i &lt; size; ++i) {            if (r.getValue(i) != null || r.field(i).getDataType().nullable())                continue;            r.changed(i, false);//标记该字段不更新        }        r.update();        r.insert();        r.delete();</code></pre><h2 id="2-2-批量方法"><a href="#2-2-批量方法" class="headerlink" title="2.2 批量方法"></a>2.2 批量方法</h2><p>新增,修改,删除批量方法都是接受一个UpdatableRecord对象集合来进行批量新增或批量修改.</p><pre><code>//批量添加DSL.using(conf).batchInsert(rs).execute();//批量修改DSL.using(conf).batchUpdate(rs).execute();//批量删除DSL.using(conf).batchDelete(rs).execute();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;jooq基本操作介绍&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="jooq" scheme="http://www.zhz.gift/tags/jooq/"/>
    
  </entry>
  
  <entry>
    <title>Application属性文件</title>
    <link href="http://www.zhz.gift/2017/12/17/Application%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6/"/>
    <id>http://www.zhz.gift/2017/12/17/Application属性文件/</id>
    <published>2017-12-16T16:07:42.000Z</published>
    <updated>2017-12-17T12:10:39.804Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Application属性文件</strong></p><a id="more"></a><p>SpringApplication    将从以下位置加载     application.properties    文件，并把<br>它们添加到Spring          Environment    中：</p><ol><li><p>当前目录下的     /config    子目录。</p></li><li><p>当前目录。</p></li><li><p>classpath下的     /config    包。</p></li><li><p>classpath根路径（root）。</p></li></ol><p>该列表是按优先级排序的（列表中位置高的路径下定义的属性将覆盖位置低的）。<br>注    你可以使用YAML（’.yml’）文件替代’.properties’。</p><p>如果不喜欢将     application.properties    作为配置文件名，你可以通过指<br>定     spring.config.name    环境属性来切换其他的名称，也可以使<br>用     spring.config.location    环境属性引用一个明确的路径（目录位置或文件路<br>径列表以逗号分割）。</p><pre><code>$    java    -jar    myproject.jar    --spring.config.name=myproject或$    java    -jar    myproject.jar    --spring.config.location=classpath:/default.properties,classpath:/override.properties</code></pre><p>注    在初期需要根据     spring.config.name    和     spring.config.location    决定加<br>载哪个文件，所以它们必须定义为environment属性（通常为OS    env，系统属性或<br>命令行参数）。</p><p>如果     spring.config.location    包含目录（相对于文件），那它们应该以     /    结尾<br>（在被加载前，     spring.config.name    关联的名称将被追加到后面，包括profile-<br>specific的文件名）。     spring.config.location    下定义的文件使用方法跟往常一<br>样，没有profile-specific变量支持的属性，将被profile-specific的属性覆盖。</p><p>不管     spring.config.location    配置什么值，默认总会按<br>照     classpath:,classpath:/config,file:,file:config/    的顺序进行搜索，优<br>先级由低到高，也就是     file:config/    获胜。<br>如果你指定自己的位置，它们会优先于所有的默认位置（locations），并使用相同的由低到高的优先级顺序。<br>那样，你就可以在     application.properties    为应用设置默认值，然后在运行的时候使<br>用不同的文件覆盖它，同时保留默认配置。</p><p>注    如果使用环境变量而不是系统属性，需要注意多数操作系统的key名称不允许以<br>句号分割（period-separated），但你可以使用下划线（underscores）代替（比<br>如，使用     SPRING_CONFIG_NAME    代替     spring.config.name    ）。<br>注    如果应用运行在容器中，那么JNDI属性（java:comp/env）或servlet上下文初始<br>化参数可以用来代替环境变量或系统属性，当然也可以使用环境变量或系统属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Application属性文件&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://www.zhz.gift/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>WEB环境下进行单元测试</title>
    <link href="http://www.zhz.gift/2017/12/17/WEB%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://www.zhz.gift/2017/12/17/WEB环境下进行单元测试/</id>
    <published>2017-12-16T16:07:42.000Z</published>
    <updated>2017-12-17T12:11:06.369Z</updated>
    
    <content type="html"><![CDATA[<p><strong>WEB环境下进行单元测试</strong></p><a id="more"></a><p> SpringApplication    将尝试为你创建正确类型的     ApplicationContext    ，默认<br>情况下，根据你开发的是否为web应用决定使<br>用     AnnotationConfigApplicationContext    或     AnnotationConfigEmbeddedWeb<br>ApplicationContext    。<br>用于确定是否为web环境的算法相当简单（判断是否存在某些类），你可以使<br>用     setWebEnvironment(boolean    webEnvironment)    覆盖默认行为。<br>通过调用     setApplicationContextClass(…)    ，你可以完全控<br>制     ApplicationContext    的类型。<br>注    在Junit测试中使用     SpringApplication    ，调<br>用     <strong>setWebEnvironment(false)</strong>    是很有意义的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;WEB环境下进行单元测试&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://www.zhz.gift/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot日志</title>
    <link href="http://www.zhz.gift/2017/12/17/SpringBoot%E6%97%A5%E5%BF%97/"/>
    <id>http://www.zhz.gift/2017/12/17/SpringBoot日志/</id>
    <published>2017-12-16T16:07:42.000Z</published>
    <updated>2017-12-17T12:12:51.622Z</updated>
    
    <content type="html"><![CDATA[<p><strong>SpringBoot日志</strong></p><a id="more"></a><p>##日志格式##</p><p>Spring    Boot默认的日志输出格式如下：</p><pre><code>2014-03-05    10:57:51.112        INFO    45469    ---    [main]org.apache.catalina.core.StandardEngine        :    Starting    Servlet    Engine:    Apache    Tomcat/7.0.522014-03-05    10:57:51.253        INFO    45469    ---    [ost-startStop-1]    o.a.c.c.C.[Tomcat].[localhost].[/]                            :    Initializing    Spring    embedded    WebApplicationContext2014-03-05    10:57:51.253        INFO    45469    ---    [ost-startStop-1]    o.s.web.context.ContextLoader                                                :    Root    WebApplicationContext:    initialization    completed    in    1358    ms2014-03-05    10:57:51.698        INFO    45469    ---    [ost-startStop-1]    o.s.b.c.e.ServletRegistrationBean                                :    Mapping    servlet:    &apos;dispatcherServlet&apos;    to    [/]2014-03-05    10:57:51.702        INFO    45469    ---    [ost-startStop-1]    o.s.b.c.embedded.FilterRegistrationBean        :    Mapping    filter:    &apos;hiddenHttpMethodFilter&apos;    to:    [/*]</code></pre><p>输出的节点（items）如下：</p><ol><li>日期和时间    -    精确到毫秒，且易于排序。</li><li>日志级别    -          ERROR    ,          WARN    ,          INFO    ,          DEBUG        或          TRACE    。</li><li>Process    ID。</li><li>—    分隔符，用于区分实际日志信息开头。</li><li>线程名    -    包括在方括号中（控制台输出可能会被截断）。</li><li>日志名    -    通常是源class的类名（缩写）。</li><li>日志信息。<br>注    Logback没有     FATAL    级别，它会映射到     ERROR    。</li></ol><p>##控制台输出##</p><p>默认的日志配置会在写日志消息时将它们回显到控制台，级别为     ERROR    ,WARN    和     INFO    的消息会被记录。你可以在启动应用时，通过     –debug    标识开启控制台的DEBUG级别日志记录，也可以在application.properties    中指定     debug=true    。</p><pre><code>$    java    -jar    myapp.jar    --debug</code></pre><p>当debug模式启用时，一系列核心loggers（内嵌容器，Hibernate，Spring    Boot<br>等）记录的日志会变多，但不会输出所有的信息。<br>相应地，你可以在启动应用时，通过     –trace    （或在     application.properties    设置     trace=true    ）启用”trace”模式，该模式能够追踪核心loggers（内嵌容器，Hibernate生成的schema，Spring全部的portfolio）的所有日志信息。    </p><p>##文件输出##</p><p>默认情况下，SpringBoot只会将日志记录到控制台，而不写进日志文件，如果需要，你可以设置     logging.file    或     logging.path    属性（例如     application.properties    ）。<br>下表展示如何组合使用     logging.*    ：</p><table><thead><tr><th style="text-align:center">logging.file</th><th style="text-align:center">logging.path</th><th style="text-align:center">示例</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">(none)</td><td style="text-align:center">(none)</td><td style="text-align:center"></td><td style="text-align:center">只记录到控制台</td></tr><tr><td style="text-align:center">Specific    file</td><td style="text-align:center">(none)</td><td style="text-align:center">my.log</td><td style="text-align:center">写到特定的日志文件，名称可以是精确的位置或相对于当前目录</td></tr><tr><td style="text-align:center">(none)</td><td style="text-align:center">Specific directory</td><td style="text-align:center">/var/log</td><td style="text-align:center">写到特定目录下的     spring.log    里，名称可以是精确的位置或相对于当前目录</td></tr></tbody></table><p>日志文件每达到10M就会被分割，跟控制台一样，默认记录     ERROR    ,WARN    和     INFO    级别的信息。</p><p>##日志级别##</p><p>所有Spring    Boot支持的日志系统都可以在Spring          Environment    中设置级别（     application.properties    里也一样），设置格式为’logging.level.*=LEVEL’，其中     LEVEL    是     TRACE    ,          DEBUG    ,          INFO    ,          WARN    ,          ERROR    ,          FATAL    ,          OFF    之一：<br>以下是     application.properties    示例：</p><pre><code>logging.level.root=WARNlogging.level.org.springframework.web=DEBUGlogging.level.org.hibernate=ERROR</code></pre><p>注    默认情况，Spring    Boot会重新映射Thymeleaf的     INFO    信息到     DEBUG    级别，这<br>能减少标准日志输出的噪声。查看LevelRemappingAppender可以按自己的配置设<br>置映射。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;SpringBoot日志&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://www.zhz.gift/tags/SpringBoot/"/>
    
      <category term="log" scheme="http://www.zhz.gift/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Spring WebMVC框架</title>
    <link href="http://www.zhz.gift/2017/12/17/Spring_Web_MVC%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.zhz.gift/2017/12/17/Spring_Web_MVC框架/</id>
    <published>2017-12-16T16:07:42.000Z</published>
    <updated>2017-12-17T12:11:43.347Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Spring WebMVC框架</strong></p><a id="more"></a><p>Spring    Web    MVC框架（通常简称为”SpringMVC”）是一个富“模型，视图，控制器”web框架，    允许用户创建特定的     @Controller    或     @RestController        beans来处理传入的HTTP请求，通过@RequestMapping注解可以将控制器中的方法映射到相应的HTTP请求。<br>示例：</p><pre><code>@RestController@RequestMapping(value=&quot;/users&quot;)public    class    MyRestController    {                @RequestMapping(value=&quot;/{user}&quot;,    method=RequestMethod.GET)                public    User    getUser(@PathVariable    Long    user)    {                                //    ...                }                @RequestMapping(value=&quot;/{user}/customers&quot;,    method=RequestMethod.GET)                List&lt;Customer&gt;    getUserCustomers(@PathVariable    Long    user)    {                                //    ...                }                @RequestMapping(value=&quot;/{user}&quot;,    method=RequestMethod.DELETE)                public    User    deleteUser(@PathVariable    Long    user)    {                                //    ...                }}</code></pre><p>Spring    MVC是Spring框架的核心部分，详细信息可以参考reference<br>documentation，spring.io/guides也有一些可用的指导覆盖Spring    MVC。</p><h2 id="Spring-MVC自动配置"><a href="#Spring-MVC自动配置" class="headerlink" title="Spring    MVC自动配置"></a>Spring    MVC自动配置</h2><p>Spring    Boot为Spring    MVC提供的auto-configuration适用于大多数应用，并在<br>Spring默认功能上添加了以下特性：</p><ol><li>引入     ContentNegotiatingViewResolver    和     BeanNameViewResolver<br>beans。</li><li>对静态资源的支持，包括对WebJars的支持。</li><li>自动注册     Converter    ，     GenericConverter    ，     Formatter        beans。</li><li>对     HttpMessageConverters    的支持。</li><li>自动注册     MessageCodeResolver    。</li><li>对静态     index.html    的支持。</li><li>对自定义     Favicon    的支持。</li><li>自动使用     ConfigurableWebBindingInitializer        bean。</li></ol><p>如果保留Spring    Boot    MVC特性，你只需添加其他的MVC配置（拦截器，格式化处理器，视图控制器等）。你可以添加自己的     WebMvcConfigurerAdapter    类型的@Configuration类，而不需要注解@EnableWebMvc。如果希望使用自定义的     RequestMappingHandlerMapping    ，RequestMappingHandlerAdapter    ，或     ExceptionHandlerExceptionResolver，你可以声明一个WebMvcRegistrationsAdapter    实例提供这些组件。</p><p>如果想全面控制Spring    MVC，你可以添加自己的     @Configuration    ，并使用     @EnableWebMvc    注解。</p><p>##HttpMessageConverters##</p><p>Spring    MVC使用     HttpMessageConverter    接口转换HTTP请求和响应，合适的默认配置可以开箱即用，例如对象自动转换为JSON（使用Jackson库）或XML（如果Jackson XML扩展可用，否则使用JAXB），字符串默认使用     UTF-8    编码。<br>可以使用Spring    Boot的     HttpMessageConverters    类添加或自定义转换类：</p><pre><code>import    org.springframework.boot.autoconfigure.web.HttpMessageConverters;import    org.springframework.context.annotation.*;import    org.springframework.http.converter.*;@Configurationpublic    class    MyConfiguration    {                @Bean                public    HttpMessageConverters    customConverters()    {                                HttpMessageConverter&lt;?&gt;    additional    =    ...                                HttpMessageConverter&lt;?&gt;    another    =    ...                                return    new    HttpMessageConverters(additional,    another);                }}</code></pre><p>上下文中出现的所有     HttpMessageConverter        bean都将添加到converters列表，你可以通过这种方式覆盖默认的转换器列表（converters）。    </p><p>##自定义JSON序列化器和反序列化器##</p><p>如果使用Jackson序列化，反序列化JSON数据，你可能想编写自己的     JsonSerializer    和     JsonDeserializer    类。自定义序列化器（serializers）通常通过Module注册到Jackson，但Spring    Boot提供了     @JsonComponent    注解这一替代方式，它能轻松的将序列化器注册为Spring    Beans。</p><p>##MessageCodesResolver##</p><p>Spring    MVC有一个实现策略，用于从绑定的errors产生用来渲染错误信息的错误码：     MessageCodesResolver    。SpringBoot会自动为你创建该实现，只要设置spring.mvc.message-codes-resolver.format    属性为     PREFIX_ERROR_CODE    或     POSTFIX_ERROR_CODE    （具体查看     DefaultMessageCodesResolver.Format    枚举值）。</p><p>##静态内容##</p><p>默认情况下，Spring    Boot从classpath下的     /static    （     /public    ，     /resources    或     /META-INF/resources    ）文件夹，或从ServletContext    根目录提供静态内容。</p><p>这是通过Spring    MVC的     ResourceHttpRequestHandler    实现的，你可以自定义WebMvcConfigurerAdapter    并覆写addResourceHandlers    方法来改变该行为（加载静态文件）。</p><p>在单机web应用中，容器会启动默认的servlet，并用它加载     ServletContext    根目录下的内容以响应那些Spring不处理的请求。大多数情况下这都不会发生（除非你修改默认的MVC配置），因为Spring总能够通过     DispatcherServlet    处理这些请求。</p><p>你可以设置     spring.resources.staticLocations    属性自定义静态资源的位置（配置一系列目录位置代替默认的值），如果你这样做，默认的欢迎页面将从自定义位置加载，所以只要这些路径中的任何地方有一个     index.html    ，它都会成为应用的主页。</p><p>此外，除了上述标准的静态资源位置，有个例外情况是Webjars内容。任何在 /webjars/**    路径下的资源都将从jar文件中提供，只要它们以Webjars的格式<br>打包。</p><p>注    如果你的应用将被打包成jar，那就不要使用     src/main/webapp文件夹。尽管该文件夹是通常的标准格式，但它仅在打包成war的情况下起作用，在打包成jar时，多数构建工具都会默认忽略它。</p><p>Spring    Boot也支持SpringMVC提供的高级资源处理特性，可用于清除缓存的静态资源或对WebJar使用版本无感知的URLs。</p><p>如果想使用针对WebJars版本无感知的URLs（version    agnostic），只需要添<br>加     webjars-locator    依赖，然后声明你的Webjar。以jQuery为例，     “/webjars/jquery/dist/jquery.min.js”    实际<br>为     “/webjars/jquery/x.y.z/dist/jquery.min.js”    ，     x.y.z为Webjar的版<br>本。</p><p>注    如果使用JBoss，你需要声明     webjars-locator-jboss-vfs    依赖而不是     webjars-locator    ，否则所有的Webjars将解析为     404    。</p><p>以下的配置为所有的静态资源提供一种缓存清除（cache    busting）方案，实际上是<br>将内容hash添加到URLs中，比如     <link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css">    ：</p><pre><code>spring.resources.chain.strategy.content.enabled=truespring.resources.chain.strategy.content.paths=/**</code></pre><p>注    实现该功能的是     ResourceUrlEncodingFilter    ，它在模板运行期会重写资源链接，Thymeleaf，Velocity和FreeMarker会自动配置该filter，JSP需要手动配置。<br>其他模板引擎还没自动支持，不过你可以使用ResourceUrlProvider自定义模块宏或<br>帮助类。<br>当使用比如JavaScript模块加载器动态加载资源时，重命名文件是不行的，这也是提供其他策略并能结合使用的原因。下面是一个”fixed”策略，在URL中添加一个静态version字符串而不需要改变文件名：    </p><pre><code>spring.resources.chain.strategy.content.enabled=truespring.resources.chain.strategy.content.paths=/**spring.resources.chain.strategy.fixed.enabled=truespring.resources.chain.strategy.fixed.paths=/js/lib/spring.resources.chain.strategy.fixed.version=v12</code></pre><p>使用以上策略，JavaScript模块加载器加载     “/js/lib/“下的文件时会使用一个固定的版本策略     “/v12/js/lib/mymodule.js”    ，其他资源仍旧使用内容hash的方式     <link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css">    。</p><p>查看ResourceProperties获取更多支持的选项。<br>注    该特性在一个专门的博文和Spring框架参考文档中有透彻描述。    </p><p>##ConfigurableWebBindingInitializer##</p><p>Spring    MVC使用     WebBindingInitializer    为每个特殊的请求初始化相应的WebDataBinder    ，如果你创建自己的     ConfigurableWebBindingInitializer @Bean    ，Spring    Boot会自动配置Spring    MVC使用它。</p><p>##模板引擎##</p><p>正如REST    web服务，你也可以使用Spring    MVC提供动态HTML内容。Spring    MVC<br>支持各种各样的模板技术，包括Velocity,    FreeMarker和JSPs，很多其他的模板引擎也提供它们自己的Spring    MVC集成。</p><p>Spring    Boot为以下的模板引擎提供自动配置支持：</p><ol><li>FreeMarker</li><li>Groovy</li><li>Thymeleaf</li><li>Velocity（1.4已不再支持）</li><li>Mustache</li><li>注：由于在内嵌servlet容器中使用JSPs存在一些已知的限制，所以建议尽量不使用它们。</li></ol><p>使用以上引擎中的任何一种，并采用默认配置，则模块会从src/main/resources/templates    自动加载。</p><p>注：IntelliJ    IDEA根据你运行应用的方式会对classpath进行不同的排序。<br>在IDE里通过main方法运行应用，跟从Maven，或Gradle，或打包好的jar中运行相比会导致不同的顺序，这可能导致SpringBoot不能从classpath下成功地找到模板。<br>如果遇到这个问题，你可以在IDE里重新对classpath进行排序，将模块的类和资源放到第一位。<br>或者，你可以配置模块的前缀为     classpath*:/templates/    ，这样会查找<br>classpath下的所有模板目录。</p><p>##错误处理##</p><p>Spring    Boot默认提供一个     /error    映射用来以合适的方式处理所有的错误，并将它注册为servlet容器中全局的    错误页面。<br>对于机器客户端（相对于浏览器而言，浏览器偏重于人的行为），它会产生一个具有详细错误，HTTP状态，异常信息的JSON响应。对于浏览器客户端，它会产生一个白色标签样式（whitelabel）的错误视图，该视图将以HTML格式显示同样的数据（可以添加一个解析为’error’的View来自定义它）。<br>为了完全替换默认的行为，你可以实现     ErrorController    ，并注册一个该类型的bean定义，或简单地添加一个     ErrorAttributes    类型的bean以使用现存的机制，只是替换显示的内容。</p><p>注          BasicErrorController    可以作为自定义     ErrorController    的基类，如果你想添加对新context    type的处理（默认处理     text/html    ），这会很有帮助。<br>你只需要继承     BasicErrorController，添加一个public方法，并注解带有     produces    属性的     @RequestMapping，然后创建该新类型的bean。<br>你也可以定义一个@ControllerAdvice去自定义某个特殊controller或exception类型的JSON文档：</p><pre><code>@ControllerAdvice(basePackageClasses    =    FooController.class)public    class    FooControllerAdvice    extends    ResponseEntityExceptionHandler    {                @ExceptionHandler(YourException.class)                @ResponseBody                ResponseEntity&lt;?&gt;    handleControllerException(HttpServletRequest    request,    Throwable    ex)    {                                HttpStatus    status    =    getStatus(request);                                return    new    ResponseEntity&lt;&gt;(new    CustomErrorType(status.value(),    ex.getMessage()),    status);                }                private    HttpStatus    getStatus(HttpServletRequest    request)    {                                Integer    statusCode    =    (Integer)    request.getAttribute(&quot;javax.servlet.error.status_code&quot;);                                if    (statusCode    ==    null)    {                                                return    HttpStatus.INTERNAL_SERVER_ERROR;                                }                                return    HttpStatus.valueOf(statusCode);                }}</code></pre><p>在以上示例中，如果跟     FooController相同package的某个controller抛出     YourException    ，一个     CustomerErrorType    类型的POJO的json展示将代替     ErrorAttributes    展示。</p><p>自定义错误页面</p><p>如果想为某个给定的状态码展示一个自定义的HTML错误页面，你需要将文件添加到     /error    文件夹下。错误页面既可以是静态HTML（比如，任何静态资源文件夹下添加的），也可以是使用模板构建的，文件名必须是明确的状态码或一系列标签。</p><p>例如，映射     404    到一个静态HTML文件，你的目录结构可能如下：    </p><pre><code>src/    +-    main/            +-    java/            |            +    &lt;source    code&gt;            +-    resources/                        +-    public/                            +-    error/                                |    +-    404.html                            +-    &lt;other    public    assets&gt;    </code></pre><p>使用FreeMarker模板映射所有     5xx    错误，你需要如下的目录结构：</p><pre><code>src/    +-    main/            +-    java/            |            +    &lt;source    code&gt;            +-    resources/                    +-    templates/                            +-    error/                            |            +-    5xx.ftl                            +-    &lt;other    templates&gt;</code></pre><p>对于更复杂的映射，你可以添加实现     ErrorViewResolver接口的beans：</p><pre><code>public    class    MyErrorViewResolver    implements    ErrorViewResolver    {                @Override    public    ModelAndViewresolveErrorView(HttpServletRequest    request,HttpStatus    status,Map&lt;String,    Object&gt;    model)    {    //    Use    the    request    or    status    to    optionally    return    a    ModelAndView                    return    ...    }}</code></pre><p>你也可以使用Spring    MVC特性，比如@ExceptionHandler方法和@ControllerAdvice，ErrorController    将处理所有未处理的异常。</p><p>映射Spring    MVC以外的错误页面</p><p>对于不使用Spring    MVC的应用，你可以通过     ErrorPageRegistrar    接口直接注册     ErrorPages。<br>该抽象直接工作于底层内嵌servlet容器，即使你没有SpringMVC的DispatcherServlet    ，它们仍旧可以工作。    </p><pre><code>@Beanpublic    ErrorPageRegistrar    errorPageRegistrar(){                return    new    MyErrorPageRegistrar();}//    ...private    static    class    MyErrorPageRegistrar    implements    ErrorPageRegistrar    {                @Override                public    void    registerErrorPages(ErrorPageRegistry    registry)    {                                registry.addErrorPages(new    ErrorPage(HttpStatus.BAD_REQUEST,    &quot;/400&quot;));                }}</code></pre><p>注.如果你注册一个     ErrorPage    ，该页面需要被一个     Filter    处理（在一些非Spring    web框架中很常见，比如Jersey，Wicket），那么该     Filter    需要明确注册为一个     ERROR    分发器（dispatcher），例如：    </p><pre><code>@Beanpublic    FilterRegistrationBean    myFilter()    {                FilterRegistrationBean    registration    =    new    FilterRegistrationBean();                registration.setFilter(new    MyFilter());                ...                registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));                return    registration;}</code></pre><p>（默认的     FilterRegistrationBean    不包含     ERROR        dispatcher类型）。</p><p>WebSphere应用服务器的错误处理当部署到一个servlet容器时，Spring    Boot通过它的错误页面过滤器将带有错误状态的请求转发到恰当的错误页面。</p><p>request只有在response还没提交时才能转发（forwarded）到正确的错误页面，而WebSphere应用服务器8.0及后续版本默认情况会在servlet方法成功执行后提交response，你需要设置     com.ibm.ws.webcontainer.invokeFlushAfterService    属性为     false    来关闭该行为。    </p><p>##Spring HATEOAS##</p><p>如果正在开发基于超媒体的RESTful    API，你可能需要Spring    HATEOAS，而Spring<br>Boot会为其提供自动配置，这在大多数应用中都运作良好。</p><p>自动配置取代了     @EnableHypermediaSupport    ，只需注册一定数量的beans就能轻松构建基于超媒体的应用，这些beans包括     LinkDiscoverers    （客户端支持），     ObjectMapper    （用于将响应编排为想要的形式）。</p><p>ObjectMapper    可以根据     spring.jackson.*    属性或     Jackson2ObjectMapperBuilder        bean进行自定义。</p><p>通过注解     @EnableHypermediaSupport    ，你可以控制Spring    HATEOAS的配置，<br>但这会禁用上述     ObjectMapper    的自定义功能。</p><p>##CORS支持##</p><p>跨域资源共享（CORS）是一个大多数浏览器都实现了的W3C标准，它允许你以灵活的方式指定跨域请求如何被授权，而不是采用那些不安全，性能低的方式，比如IFRAME或JSONP。</p><p>从4.2版本开始，Spring MVC对CORS提供开箱即用的支持。不用添加任何特殊配置，只需要在Spring    Boot应用的controller方法上注解     @CrossOrigin    ，并添加CORS配置。<br>通过注册一个自定义     addCorsMappings(CorsRegistry)    方法的WebMvcConfigurer        bean可以指定全局CORS配置：</p><pre><code>@Configurationpublic    class    MyConfiguration    {            @Bean            public    WebMvcConfigurer    corsConfigurer()    {                                return    new    WebMvcConfigurerAdapter()    {                                                @Override            public    void    addCorsMappings(CorsRegistry    registry)    {                                                                registry.addMapping(&quot;/api/**&quot;);                                                }                                };            }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Spring WebMVC框架&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://www.zhz.gift/tags/SpringBoot/"/>
    
      <category term="MVC" scheme="http://www.zhz.gift/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot应用启动事件</title>
    <link href="http://www.zhz.gift/2017/12/17/SpringBoot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E4%BA%8B%E4%BB%B6/"/>
    <id>http://www.zhz.gift/2017/12/17/SpringBoot应用启动事件/</id>
    <published>2017-12-16T16:07:42.000Z</published>
    <updated>2017-12-17T12:10:53.646Z</updated>
    
    <content type="html"><![CDATA[<p><strong>SpringBoot应用启动事件</strong></p><a id="more"></a><p><strong>监听Spring boot应用的事件只需实现ApplicationListener接口来监听对应事件.</strong></p><p>有些事件实际上是在    ApplicationContext    创建前触发的，所以你不能在那些</p><p>事件（处理类）中通过    @Bean    注册监听器，只能通</p><p>过    SpringApplication.addListeners(…)    或    SpringApplicationBuilder.lis</p><p>teners(…)    方法注册.</p><p>应用运行时，事件会以下面的次序发送：</p><ol><li>在运行开始，但除了监听器注册和初始化以外的任何处理之前，会发送一</li></ol><p>个    ApplicationStartedEvent    。</p><ol><li>在Environment将被用于已知的上下文，但在上下文被创建前，会发送一</li></ol><p>个    ApplicationEnvironmentPreparedEvent    。</p><ol><li>在refresh开始前，但在bean定义已被加载后，会发送一</li></ol><p>个    ApplicationPreparedEvent    。</p><ol><li>在refresh之后，相关的回调处理完，会发送一个    ApplicationReadyEvent    ，</li></ol><p>表示应用准备好接收请求了。</p><ol><li>启动过程中如果出现异常，会发送一个    ApplicationFailedEvent    。</li></ol><p>注    通常不需要使用application事件，但知道它们的存在是有用的（在某些场合可能</p><p>会使用到），比如，在Spring    Boot内部会使用事件处理各种任务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;SpringBoot应用启动事件&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://www.zhz.gift/tags/SpringBoot/"/>
    
      <category term="event" scheme="http://www.zhz.gift/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>第三方配置</title>
    <link href="http://www.zhz.gift/2017/12/17/%E7%AC%AC%E4%B8%89%E6%96%B9%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.zhz.gift/2017/12/17/第三方配置/</id>
    <published>2017-12-16T16:07:42.000Z</published>
    <updated>2017-12-17T12:12:37.019Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第三方配置</strong></p><a id="more"></a><p>@ConfigurationProperties    不仅可以注解在类上，也可以注解在public @Bean    方法上，当你需要为不受控的第三方组件绑定属性时，该方法将非常有<br>用。为了从     Environment属性中配置一个bean，你需要使用@ConfigurationProperties    注解该bean：</p><pre><code>@ConfigurationProperties(prefix    =    &quot;foo&quot;)@Beanpublic    FooComponent    fooComponent()    {                ...}</code></pre><p>和上面     ConnectionSettings    的示例方式相同，所有以foo为前缀的属性定义都会被映射到     FooComponent    上。</p><p>##Relaxed绑定##</p><p>Spring    Boot将     Environment    属性绑定到     @ConfigurationProperties        beans时会使用一些宽松的规则，所以     Environment属性名和bean属性名不需要精确匹配。常见的示例中有用的包括虚线分割（比如，     context-path    绑定到     contextPath    ），将environment属性转为大写字母（比如，     PORT    绑定     port    ）。<br>例如，给定以下     @ConfigurationProperties    类：</p><pre><code>@ConfigurationProperties(prefix=&quot;person&quot;)public    class    OwnerProperties    {                private    String    firstName;                public    String    getFirstName()    {                                return    this.firstName;                }                public    void    setFirstName(String    firstName)    {                                this.firstName    =    firstName;                }}</code></pre><p>下面的属性名都能使用：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">person.firstName</td><td style="text-align:center">标准驼峰规则</td></tr><tr><td style="text-align:center">person.first-name</td><td style="text-align:center">虚线表示，推荐用于     .properties    和     .yml文件中</td></tr><tr><td style="text-align:center">person.first_name</td><td style="text-align:center">下划线表示，用于     .properties    和     .yml    文件的可选格式</td></tr><tr><td style="text-align:center">PERSON_FIRST_NAME</td><td style="text-align:center">大写形式，使用系统环境变量时推荐</td></tr></tbody></table><p>##属性转换##</p><p>将外部应用配置绑定到     @ConfigurationProperties        beans时，Spring会尝试将属性强制转换为正确的类型。如果需要自定义类型转换器，你可以提供一个ConversionService        bean（bean    id为     conversionService    ），或自定义属性编辑器（通过     CustomEditorConfigurer        bean），或自定义     Converters    （bean定义时需要注解     @ConfigurationPropertiesBinding    ）。</p><p>注    由于该bean在应用程序生命周期的早期就需要使用，所以确保限制你的     ConversionService使用的依赖。通常，在创建时期任何你需要的依赖可能都<br>没完全初始化。        </p><p>##@ConfigurationProperties校验##</p><p>Spring    Boot将尝试校验外部配置，默认使用JSR-303（如果在classpath路径中），你只需要将JSR-303          javax.validation    约束注解添加到     @ConfigurationProperties    类上：</p><pre><code>@ConfigurationProperties(prefix=&quot;connection&quot;)public    class    ConnectionProperties    {                @NotNull                private    InetAddress    remoteAddress;                //    ...    getters    and    setters}</code></pre><p>为了校验内嵌属性的值，你需要使用     @Valid    注解关联的字段以触发它的校验，例<br>如：    </p><pre><code>@ConfigurationProperties(prefix=&quot;connection&quot;)public    class    ConnectionProperties    {                @NotNull                @Valid                private    RemoteAddress    remoteAddress;                //    ...    getters    and    setters                public    static    class    RemoteAddress    {                                @NotEmpty                                public    String    hostname;                                //    ...    getters    and    setters                }}</code></pre><p>你也可以通过创建一个叫做     configurationPropertiesValidator    的bean来添加自定义的Spring          Validator    。     @Bean    方法需要声明为     static    ，因为配置属性校验器在应用程序生命周期中创建的比较早，将     @Bean    方法声明为     static    允许该bean在创建时不需要实例化     @Configuration    类，从而避免了早期实例化（early    instantiation）的所有问题。相关的示例可以看这里。</p><p>注          spring-boot-actuator    模块包含一个暴露所有     @ConfigurationProperties        beans的端点（endpoint），通过浏览器打开     /configprops    进行浏览，或使用等效的JMX端点，具体参考Production    readyfeatures。    </p><h2 id="ConfigurationProperties-vs-Value"><a href="#ConfigurationProperties-vs-Value" class="headerlink" title="@ConfigurationProperties    vs.    @Value"></a>@ConfigurationProperties    vs.    @Value</h2><p>@Value    是Spring容器的一个核心特性，它没有提供跟type-safe    Configuration<br>Properties相同的特性。下面的表格总结了     @ConfigurationProperties    和     @Value    支持的特性：</p><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td style="text-align:center">Relaxed绑定</td><td style="text-align:center">Yes</td><td>No</td></tr><tr><td style="text-align:center">Meta-data支持</td><td style="text-align:center">Yes</td><td>No</td></tr><tr><td style="text-align:center">SpEL表达式</td><td style="text-align:center">No</td><td>Yes</td></tr></tbody></table><p>如果你为自己的组件定义了一系列的配置keys，我们建议你将它们以@ConfigurationProperties    注解的POJO进行分组。<br>由于     @Value    不支持relaxed绑定，所以如果你使用环境变量提供属性值的话，它就不是很好的选择。最后，尽管     @Value    可以写     SpEL表达式，但这些表达式不会处理来自Application属性文件的属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;第三方配置&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://www.zhz.gift/tags/SpringBoot/"/>
    
      <category term="config" scheme="http://www.zhz.gift/tags/config/"/>
    
  </entry>
  
  <entry>
    <title>使用CommandLineRunner或ApplicationRunner</title>
    <link href="http://www.zhz.gift/2017/12/17/%E4%BD%BF%E7%94%A8CommandLineRunner%E6%88%96ApplicationRunner/"/>
    <id>http://www.zhz.gift/2017/12/17/使用CommandLineRunner或ApplicationRunner/</id>
    <published>2017-12-16T16:07:42.000Z</published>
    <updated>2017-12-17T12:11:22.286Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用CommandLineRunner或ApplicationRunner</strong></p><a id="more"></a><p>如果需要在     SpringApplication    启动后执行一些特殊的代码，你可以实<br>现     ApplicationRunner    或     CommandLineRunner    接口，这两个接口工作方式相<br>同，都只提供单一的     run    方法，该方法仅在     SpringApplication.run(…)    完成<br>之前调用。<br>     CommandLineRunner    接口能够访问string数组类型的应用参数，<br>而     ApplicationRunner    使用的是上面描述过的     ApplicationArguments    接口：</p><pre><code>import    org.springframework.boot.*import    org.springframework.stereotype.*@Componentpublic    class    MyBean    implements    CommandLineRunner    {                public    void    run(String...    args)    {                                //    Do    something...                }}</code></pre><p>如果某些定义的     CommandLineRunner    或     ApplicationRunner        beans需要以特定<br>的顺序调用，你可以实现     <strong>org.springframework.core.Ordered</strong>    接口或使<br>用     <strong>org.springframework.core.annotation.Order</strong>    注解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;使用CommandLineRunner或ApplicationRunner&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://www.zhz.gift/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用YAML代替Properties</title>
    <link href="http://www.zhz.gift/2017/12/17/%E4%BD%BF%E7%94%A8YAML%E4%BB%A3%E6%9B%BFProperties/"/>
    <id>http://www.zhz.gift/2017/12/17/使用YAML代替Properties/</id>
    <published>2017-12-16T16:07:42.000Z</published>
    <updated>2017-12-17T12:12:19.322Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用YAML代替Properties</strong></p><a id="more"></a><p>##SpringBoot支持YAML##<br>YAML是JSON的一个超集，也是一种方便的定义层次配置数据的格式。只要你<br>将SnakeYAML    库放到classpath下，     SpringApplication    就会自动支持YAML，<br>以作为properties的替换。<br>注    如果你使用’Starters’，添加     spring-boot-starter    依赖会自动加载<br>SnakeYAML。</p><p>##加载YAML##</p><p>Spring框架提供两个便利的类用于加载YAML文档，YamlPropertiesFactoryBean    会将YAML加载为     Properties    ，     YamlMapFactoryBean    会将YAML加载为     Map    。<br>例如，下面的YAML文档：</p><pre><code>environments:                dev:                                url:    http://dev.bar.com                                name:    Developer    Setup                prod:                                url:    http://foo.bar.com                                name:    My    Cool    App</code></pre><p>会被转化到这些属性：</p><pre><code>environments.dev.url=http://dev.bar.comenvironments.dev.name=Developer    Setupenvironments.prod.url=http://foo.bar.comenvironments.prod.name=My    Cool    App</code></pre><p>YAML列表被表示成使用[index]间接引用作为属性keys的形式，例如下面的<br>YAML：</p><pre><code>my:            servers:                            -    dev.bar.com                            -    foo.bar.com</code></pre><p>将会转化到这些属性:</p><pre><code>my.servers[0]=dev.bar.commy.servers[1]=foo.bar.com</code></pre><p>使用Spring          DataBinder    工具集绑定这些属性（这是@ConfigurationProperties    做的事）时，你需要确保目标bean有个     java.util.List    或     Set    类型的属性，并且需要提供一个setter或使用可变的值初始化它，比如，下面的代码将绑定上面的属性：</p><pre><code>@ConfigurationProperties(prefix=&quot;my&quot;)public    class    Config    {        private    List&lt;String&gt;    servers    =    new    ArrayList&lt;String&gt;();        public    List&lt;String&gt;    getServers(){                return    this.servers;        }}</code></pre><p>##在Spring环境中使用YAML暴露属性##</p><p>YamlPropertySourceLoader类能够将YAML作为PropertySource导出到SprigEnvironment    ，这允许你使用常用的    @Value注解配合占位符语法访问YAML属<br>性。</p><p>##Multi-profile    YAML文档##</p><p>你可以在单个文件中定义多个特定配置（profile-specific）的YAML文档，并通过     spring.profiles    标示生效的文档，例如：</p><pre><code>server:                address:    192.168.1.100---spring:                profiles:    developmentserver:                address:    127.0.0.1---spring:                profiles:    productionserver:                address:    192.168.1.120</code></pre><p>在以上例子中，如果     development        profile被激活，     server.address    属性将是     127.0.0.1    ；如果     development    和     production        profiles没有启用，则该属性的值将是     192.168.1.100    。<br>在应用上下文启动时，如果没有明确指定激活的profiles，则默认的profiles将生效。所以，在下面的文档中我们为     security.user.password    设置了一个值，该<br>值只在”default”    profile中有效：                    </p><pre><code>server:        port:    8000---spring:        profiles:    defaultsecurity:        user:                password:    weak</code></pre><p>然而，在这个示例中，由于没有关联任何profile，密码总是会设置，并且如果有必要的话可以在其他profiles中显式重置：                    </p><pre><code>server:        port:    8000security:        user:                password:    weak                    </code></pre><p>通过     !    可以对     spring.profiles指定的profiles进行取反（negated，跟java中的     !    作用一样），如果negated和non-negated    profiles都指定一个单一文件，至少需要匹配一个non-negated    profile，可能不会匹配任何negated    profiles。                    </p><p>##YAML缺点##                    </p><p>YAML文件不能通过     @PropertySource    注解加载，如果需要使用该方式，那就必须使用properties文件。</p><p>##合并YAML列表##</p><p>正如上面看到的，所有YAML最终都转换为properties，在通过一个profile覆<br>盖”list”属性时这个过程可能不够直观（counter    intuitive）。例如，假设有一<br>个     MyPojo    对象，默认它的     name    和     description    属性都为     null    ，下面我们<br>将从     FooProperties    暴露一个     MyPojo    对象列表（list）：</p><pre><code>@ConfigurationProperties(&quot;foo&quot;)public    class    FooProperties    {        private    final    List&lt;MyPojo&gt;    list    =    new    ArrayList&lt;&gt;();        public    List&lt;MyPojo&gt;    getList()    {                return    this.list;        }}</code></pre><p>考虑如下配置：</p><pre><code>foo:        list:                -    name:    my    name                        description:    my    description---spring:        profiles:    devfoo:        list:                -    name:    my    another    name</code></pre><p> 如果     dev        profile没有激活，     FooProperties.list    将包括一个如上述定义的     MyPojo    实体，即使     dev    生效，该     list    仍旧只包含一个实体（     name    值为     my    another    name    ，description    值为     null    ）。<br>此配置不会向该列表添加第二个     MyPojo    实例，也不会对该项进行合并。<br>当一个集合定义在多个profiles时，只使用优先级最高的：       </p><pre><code>foo:        list:                -    name:    my    name                        description:    my    description                -    name:    another    name                        description:    another    description---spring:        profiles:    devfoo:        list:                    -    name:    my    another    name</code></pre><p> 在以上示例中，如果     dev        profile激活，     FooProperties.list将包含一个     MyPojo    实体（     name    值为     my    another    name    ，     description    值为     null    ）。   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;使用YAML代替Properties&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://www.zhz.gift/tags/SpringBoot/"/>
    
      <category term="YAML" scheme="http://www.zhz.gift/tags/YAML/"/>
    
  </entry>
  
  <entry>
    <title>spring boot简介</title>
    <link href="http://www.zhz.gift/2017/12/02/spring-boot%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.zhz.gift/2017/12/02/spring-boot简介/</id>
    <published>2017-12-02T14:22:54.000Z</published>
    <updated>2017-12-03T10:38:50.690Z</updated>
    
    <content type="html"><![CDATA[<p><strong>spring boot</strong></p><p>spring boot 为所有spring框架开发者提供一种更加易于理解，更加便捷高效的开发方式；<br>通过提供更为直观的spring平台和第三方依赖库，只需要极其少量的spring配置，便能部署运行spring boot应用。</p><a id="more"></a><p>1.环境要求</p><p>Spring Boot 2.0.0.BUILD-SNAPSHOT 需要 Java 8 以及 Spring Framework 5.0.2.RELEASE 或者以上版本.<br>当使用maven或者gradle构建spring boot时需要 Maven 3.2+ 或者 Gradle 4及其以上版本.</p><p>2.spring boot安装</p><p>2.1使用maven 构建spring boot应用</p><p>pom.xml配置:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.example&lt;/groupId&gt;    &lt;artifactId&gt;myproject&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;!-- Inherit defaults from Spring Boot --&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.0.0.BUILD-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;!-- Add typical dependencies for a web application --&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;!-- Package as an executable jar --&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;!-- Add Spring repositories --&gt;    &lt;!-- (you don&apos;t need this if you are using a .RELEASE version) --&gt;    &lt;repositories&gt;        &lt;repository&gt;            &lt;id&gt;spring-snapshots&lt;/id&gt;            &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;            &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;        &lt;/repository&gt;        &lt;repository&gt;            &lt;id&gt;spring-milestones&lt;/id&gt;            &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;        &lt;/repository&gt;    &lt;/repositories&gt;    &lt;pluginRepositories&gt;        &lt;pluginRepository&gt;            &lt;id&gt;spring-snapshots&lt;/id&gt;            &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;        &lt;/pluginRepository&gt;        &lt;pluginRepository&gt;            &lt;id&gt;spring-milestones&lt;/id&gt;            &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;        &lt;/pluginRepository&gt;    &lt;/pluginRepositories&gt;&lt;/project&gt;</code></pre><p>2.2安装Spring Boot CLI</p><p>The Spring Boot CLI (Command Line Interface)是一个用于快速建立spring原型的命令行工具.<br>通过它你能运行Groovy scripts,使用熟悉的类java语法。</p><p>使用CLI来运行spring boot不是必须的,但它是使spring应用运行起来的最快方法.</p><p>2.2.1 手动安装</p><p>你可以在spring 软件仓库下载Spring CLI</p><p><a href="https://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/2.0.0.BUILD-SNAPSHOT/spring-boot-cli-2.0.0.BUILD-SNAPSHOT-bin.zip" target="_blank" rel="external">spring-boot-cli-2.0.0.BUILD-SNAPSHOT-bin.zip</a></p><p><a href="https://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/2.0.0.BUILD-SNAPSHOT/spring-boot-cli-2.0.0.BUILD-SNAPSHOT-bin.tar.gz" target="_blank" rel="external">spring-boot-cli-2.0.0.BUILD-SNAPSHOT-bin.tar.gz</a></p><p>2.2.2 通过SDKMAN安装</p><p>SDKMAN!(The Software Development Kit Manager)可以用来管理不同版本的二进制sdks,包括 Groovy和Spring Boot CLI.<br>从<a href="http://sdkman.io/" target="_blank" rel="external">sdkman.io</a>获取SDKMAN!并且通过以下命令来安装Spring Boot</p><pre><code>$ sdk install springboot$ spring --versionSpring Boot v2.0.0.BUILD-SNAPSHOT</code></pre><p>上述的安装方式都会在本地建立一个名为dev的Spring实例,它指向你的安装路径,所以你每次重建Spring Boot时,<br>spring 都会更新到最新.</p><p>你能通过以下命令看到它是如何进行的:</p><p>$ sdk ls springboot</p><pre><code>================================================================================Available Springboot Versions================================================================================&gt; + dev* 2.0.0.BUILD-SNAPSHOT================================================================================+ - local version* - installed&gt; - currently in use================================================================================    </code></pre><p>3.开发你首个Spring Boot 应用</p><p>这个章节描述了如何区开发一个\”五脏俱全\”的Spring Boot \”Hello World!\”应用.<br>我们使用Maven来构建这个项目,因为大部分IDES都支持它.</p><p><a href="https://spring.io/" target="_blank" rel="external">spring.io</a>web网站包含很多”Getting Started”的spring boot教程,<br>如果你需要解决一些特定的问题,首先查看这里.</p><p>开始之前首先检查jdk版本和maven版本是否满足要求</p><p>java -version</p><p>mvn -v</p><p>pom.xml 配置如下:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.example&lt;/groupId&gt;    &lt;artifactId&gt;myproject&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.0.0.BUILD-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;!-- Additional lines to be added here... --&gt;    &lt;!-- (you don&apos;t need this if you are using a .RELEASE version) --&gt;    &lt;repositories&gt;        &lt;repository&gt;            &lt;id&gt;spring-snapshots&lt;/id&gt;            &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;            &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;        &lt;/repository&gt;        &lt;repository&gt;            &lt;id&gt;spring-milestones&lt;/id&gt;            &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;        &lt;/repository&gt;    &lt;/repositories&gt;    &lt;pluginRepositories&gt;        &lt;pluginRepository&gt;            &lt;id&gt;spring-snapshots&lt;/id&gt;            &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;        &lt;/pluginRepository&gt;        &lt;pluginRepository&gt;            &lt;id&gt;spring-milestones&lt;/id&gt;            &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;        &lt;/pluginRepository&gt;    &lt;/pluginRepositories&gt;&lt;/project&gt;</code></pre><p>3.2 Spring Boot提供了大量的”Starters”开始器使你能在classpath路径添加jars.<br>我们普通的例子应用已经在POM的父节点使用 spring-boot-starter-parent .</p><p>spring-boot-starter-parent是一个提供了众多有用Maven默认配置的特殊启动器.<br>它同样提供了dependency-management配置使你能够为一些dependencies依赖省略 version 配置.</p><p>但你开发其它特殊类型的应用时可能需要使用到其它启动器(Starters),例如,当我们开发一个web应用时,<br>我们添加spring-boot-starter-web 依赖.在那之前,我们可以通过以下命令查看依赖树:</p><p>mvn dependency:tree</p><p>通过mvn dependency:tree命令我们可以查看项目的依赖树结构,<br>你可以看到  spring-boot-starter-parent 本身没有提供其它依赖.<br>通过编辑pom.xml添加必要的依赖</p><dependencies><br>    <dependency><br>        <groupid>org.springframework.boot</groupid><br>        <artifactid>spring-boot-starter-web</artifactid><br>    </dependency><br></dependencies><p>如果你再次运行 mvn dependency:tree 命令,你就能看到一系列新添加的依赖,<br>包括tomcat 服务器以及spring boot本身.</p><p>3.3 代码编写</p><p>为了完成应用，我们首先需要创建一个java文件.<br>在src/main/java下创建Example.java文件并添加以下代码:</p><pre><code>import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example {    @RequestMapping(&quot;/&quot;)    String home() {        return &quot;Hello World!&quot;;    }    public static void main(String[] args) throws Exception {        SpringApplication.run(Example.class, args);    }}</code></pre><p>3.3.1 @RestController 和 @RequestMapping 注解</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;spring boot&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;spring boot 为所有spring框架开发者提供一种更加易于理解，更加便捷高效的开发方式；&lt;br&gt;通过提供更为直观的spring平台和第三方依赖库，只需要极其少量的spring配置，便能部署运行spring boot应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring" scheme="http://www.zhz.gift/tags/spring/"/>
    
      <category term="框架" scheme="http://www.zhz.gift/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://www.zhz.gift/2017/12/02/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.zhz.gift/2017/12/02/快速排序/</id>
    <published>2017-12-01T16:24:16.000Z</published>
    <updated>2017-12-01T16:24:49.088Z</updated>
    
    <content type="html"><![CDATA[<p><strong>快速排序</strong></p><p>堆排序是指利用堆这种数据结构所设计的一种排序算法.堆是一种特殊的二叉树,每个子节点的值总是小于(或大于)它的父节点,相应的分为最大堆或最小堆,<br>通过最大堆或最小堆不断输出堆顶元素,直到全部元素都已输出,得到的输出元素序列即为有序序列.</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;快速排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;堆排序是指利用堆这种数据结构所设计的一种排序算法.堆是一种特殊的二叉树,每个子节点的值总是小于(或大于)它的父节点,相应的分为最大堆或最小堆,&lt;br&gt;通过最大堆或最小堆不断输出堆顶元素,直到全部元素都已输出,得到的输出元素序列即为有序序列.&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.zhz.gift/tags/java/"/>
    
      <category term="算法" scheme="http://www.zhz.gift/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://www.zhz.gift/2017/12/01/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.zhz.gift/2017/12/01/堆排序/</id>
    <published>2017-11-30T16:07:42.000Z</published>
    <updated>2017-11-30T16:53:14.523Z</updated>
    
    <content type="html"><![CDATA[<p><strong>堆排序</strong></p><p>堆排序是指利用堆这种数据结构所设计的一种排序算法.堆是一种特殊的二叉树,每个子节点的值总是小于(或大于)它的父节点,相应的分为最大堆或最小堆,<br>通过最大堆或最小堆不断输出堆顶元素,直到全部元素都已输出,得到的输出元素序列即为有序序列.</p><a id="more"></a><pre><code>import java.util.Arrays;public class HeapSort3 {    public static void main(String[] args){        int[] test = new int[]{8,11,3,6,23,14,18,7,55,34};        System.out.println(&quot;初始数组:&quot; + Arrays.toString(test));        HeapSort3.heapSort(test);        System.out.println(Arrays.toString(test));    }    public static int leftChild(int child){        return child * 2 + 1;    }    public static void precDown(int[] a,int i,int n){        int child;        int temp;        for(temp = a[i];leftChild(i) &lt; n;i = child){            child = leftChild(i);            if(i != n - 1 &amp;&amp; a[child] &lt; a[child + 1]){                child++;            }            if(a[i] &lt; a[child]){                a[i] = a[child];            }        }        a[i] = temp;    }    public static void swapReferences(int[] a,int index){        int temp = a[0];        a[0] = a[index];        a[index] = temp;    }    public static void heapSort(int[] a){        for(int i = a.length / 2;i &gt; 0;i--){            precDown(a,i,a.length - 1);        }        System.out.println(&quot;max二叉堆构建完毕:&quot; + Arrays.toString(a));        for(int k = a.length - 1;k &gt; 0;k--){            swapReferences(a,k);            precDown(a,0,k);        }    }}</code></pre><p><strong>最差时间复杂度:O(N*logN),平均时间复杂度O(N*logN),空间复杂度:O(1),不稳定算法</strong>        </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;堆排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;堆排序是指利用堆这种数据结构所设计的一种排序算法.堆是一种特殊的二叉树,每个子节点的值总是小于(或大于)它的父节点,相应的分为最大堆或最小堆,&lt;br&gt;通过最大堆或最小堆不断输出堆顶元素,直到全部元素都已输出,得到的输出元素序列即为有序序列.&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.zhz.gift/tags/java/"/>
    
      <category term="算法" scheme="http://www.zhz.gift/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://www.zhz.gift/2017/11/21/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.zhz.gift/2017/11/21/归并排序/</id>
    <published>2017-11-20T16:15:34.000Z</published>
    <updated>2017-11-20T16:32:40.377Z</updated>
    
    <content type="html"><![CDATA[<p><strong>归并排序</strong></p><p>将一个无序序列进行折半递归,直到得到单个元素的有序序列,然后递归的将折半后左右两边的有序序列依次进行合并,最终得到有序序列.</p><a id="more"></a><pre><code>import java.util.Arrays;public class MergeSort {    public static void main(String[] args){        int[] a = new int[]{11,2,5,15,23,44,24,8};        mergeSort(a);        System.out.println(Arrays.toString(a));    }    private static  void mergeSort(int[] a,int[] tmpArray,int left,int right){        if(left &lt; right){            int center = (left + right) / 2;            mergeSort(a,tmpArray,left,center);            mergeSort(a,tmpArray,center + 1,right);            merge(a,tmpArray,left,center + 1,right);        }        System.out.println(&quot;left:&quot; + left + &quot;,right:&quot; + right);    }    public static  void mergeSort(int[] a){        int[] tmpArray = new int[a.length];        mergeSort(a,tmpArray,0,a.length - 1);    }    private static  void merge(int[] a,int[] tmpArray,int leftPos,int rightPos,int rightEnd){        System.out.println(&quot;leftPos:&quot; + leftPos + &quot;,rightPos:&quot; + rightPos + &quot;,rightEnd:&quot; + rightEnd);        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        //Main loop        while(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd){            if(a[leftPos] &lt; a[rightPos]){                tmpArray[tmpPos++] = a[leftPos++];            }else{                tmpArray[tmpPos++] = a[rightPos++];            }        }        while(leftPos &lt;= leftEnd){            tmpArray[tmpPos++] = a[leftPos++];        }        while(rightPos &lt;= rightEnd){            tmpArray[tmpPos++] = a[rightPos++];        }        for(int i = 0;i &lt; numElements;i++,rightEnd--){            a[rightEnd] = tmpArray[rightEnd];        }    }}</code></pre><p><strong>最差时间复杂度:O(N^2) 平均时间复杂度O(N*logN) 空间复杂度:O(N) 稳定算法</strong>    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;归并排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将一个无序序列进行折半递归,直到得到单个元素的有序序列,然后递归的将折半后左右两边的有序序列依次进行合并,最终得到有序序列.&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.zhz.gift/tags/java/"/>
    
      <category term="算法" scheme="http://www.zhz.gift/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://www.zhz.gift/2017/11/20/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.zhz.gift/2017/11/20/希尔排序/</id>
    <published>2017-11-20T15:57:35.000Z</published>
    <updated>2017-11-20T16:14:06.358Z</updated>
    
    <content type="html"><![CDATA[<p><strong>希尔排序</strong></p><p>希尔排序(ShellSort)的名称源于它的发明者Donald Shell.<br>它通过比较相距一定间隔(h[k])的元素来工作,各躺比较所用的距离随着算法的进行而减小(h[k-1]),直到只比较相邻元素的最后一趟排序为止,因此希尔排序也称为缩减增量排序.<br>希尔排序所使用的增量序列只要h[1]=1,任何增量序列都是可行的,但其时间复杂度会有所不同.<br><a id="more"></a></p><pre><code>import java.util.*;public class Test {    public static void main(String[] args){        int[] test = new int[]{11,3,8,25,22};        Test.shellSort(test);    }    /**     * 希尔排序,使用ht=N/2 hk=h(k+1)/2的增量序列     * @param a     */    public static void shellSort(int[] a){        int hk;        int j;        for(hk = a.length / 2;hk &gt; 0 ;hk /= 2){            for(int k = hk;k &lt; a.length;k++){                int temp = a[k];                for(j = k;j &gt;= hk &amp;&amp; a[j - hk] &gt; temp;j -= hk){                    a[j] = a[j- hk];                }                a[j] = temp;            }        }        System.out.println(Arrays.toString(a));    }}</code></pre><p><strong>不稳定算法 空间复杂度O(1)</strong>    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;希尔排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;希尔排序(ShellSort)的名称源于它的发明者Donald Shell.&lt;br&gt;它通过比较相距一定间隔(h[k])的元素来工作,各躺比较所用的距离随着算法的进行而减小(h[k-1]),直到只比较相邻元素的最后一趟排序为止,因此希尔排序也称为缩减增量排序.&lt;br&gt;希尔排序所使用的增量序列只要h[1]=1,任何增量序列都是可行的,但其时间复杂度会有所不同.&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.zhz.gift/tags/java/"/>
    
      <category term="算法" scheme="http://www.zhz.gift/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://www.zhz.gift/2017/11/20/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.zhz.gift/2017/11/20/插入排序/</id>
    <published>2017-11-20T15:52:15.000Z</published>
    <updated>2017-11-20T15:57:39.472Z</updated>
    
    <content type="html"><![CDATA[<p><strong>插入排序</strong></p><p>插入排序由N-1趟排序组成,对于p=1到N-1趟,插入排序保证从位置0到位置p上的元素为已排序状态.</p><a id="more"></a><pre><code>import java.util.Arrays;public class InsertSort2 {    public static void main(String[] args){        int[] a = new int[]{11,3,6,22,15};        sort(a);        System.out.println(Arrays.toString(a));    }    //插入排序：    //将无序的元素插入到有序的元素序列中，插入后仍然有序    public static void sort(int[] a){        int k;        for(int p = 1;p &lt; a.length;p++){            int temp = a[p];            for(k = p;k &gt; 0 &amp;&amp; a[k- 1] &gt; temp;k--){                a[k] = a[k- 1];            }            a[k] = temp;        }    }}</code></pre><p><strong>最差时间复杂度:O(n^2) 平均时间复杂度O(n^2) 空间复杂度:O(1) 稳定算法</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;插入排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插入排序由N-1趟排序组成,对于p=1到N-1趟,插入排序保证从位置0到位置p上的元素为已排序状态.&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.zhz.gift/tags/java/"/>
    
      <category term="算法" scheme="http://www.zhz.gift/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
