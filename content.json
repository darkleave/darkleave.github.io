{"meta":{"title":"静默的魔法书","subtitle":"零","description":"A blog of Hans Chung","author":"Hans Chung","url":"www.zhz.gift"},"pages":[{"title":"About Me","date":"2017-11-18T11:35:43.000Z","updated":"2017-11-18T11:58:26.965Z","comments":true,"path":"about/index.html","permalink":"www.zhz.gift/about/index.html","excerpt":"","text":"I’m only a salty fish.. i will make more efforts.i promise..maybe"}],"posts":[{"title":"归并排序","slug":"归并排序","date":"2017-11-20T16:15:34.000Z","updated":"2017-11-20T16:32:40.377Z","comments":true,"path":"2017/11/21/归并排序/","link":"","permalink":"www.zhz.gift/2017/11/21/归并排序/","excerpt":"归并排序 将一个无序序列进行折半递归,直到得到单个元素的有序序列,然后递归的将折半后左右两边的有序序列依次进行合并,最终得到有序序列.","text":"归并排序 将一个无序序列进行折半递归,直到得到单个元素的有序序列,然后递归的将折半后左右两边的有序序列依次进行合并,最终得到有序序列. import java.util.Arrays; public class MergeSort { public static void main(String[] args){ int[] a = new int[]{11,2,5,15,23,44,24,8}; mergeSort(a); System.out.println(Arrays.toString(a)); } private static void mergeSort(int[] a,int[] tmpArray,int left,int right){ if(left &lt; right){ int center = (left + right) / 2; mergeSort(a,tmpArray,left,center); mergeSort(a,tmpArray,center + 1,right); merge(a,tmpArray,left,center + 1,right); } System.out.println(&quot;left:&quot; + left + &quot;,right:&quot; + right); } public static void mergeSort(int[] a){ int[] tmpArray = new int[a.length]; mergeSort(a,tmpArray,0,a.length - 1); } private static void merge(int[] a,int[] tmpArray,int leftPos,int rightPos,int rightEnd){ System.out.println(&quot;leftPos:&quot; + leftPos + &quot;,rightPos:&quot; + rightPos + &quot;,rightEnd:&quot; + rightEnd); int leftEnd = rightPos - 1; int tmpPos = leftPos; int numElements = rightEnd - leftPos + 1; //Main loop while(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd){ if(a[leftPos] &lt; a[rightPos]){ tmpArray[tmpPos++] = a[leftPos++]; }else{ tmpArray[tmpPos++] = a[rightPos++]; } } while(leftPos &lt;= leftEnd){ tmpArray[tmpPos++] = a[leftPos++]; } while(rightPos &lt;= rightEnd){ tmpArray[tmpPos++] = a[rightPos++]; } for(int i = 0;i &lt; numElements;i++,rightEnd--){ a[rightEnd] = tmpArray[rightEnd]; } } } 最差时间复杂度:O(N^2) 平均时间复杂度O(N*logN) 空间复杂度:O(N) 稳定算法","categories":[],"tags":[{"name":"java","slug":"java","permalink":"www.zhz.gift/tags/java/"},{"name":"算法","slug":"算法","permalink":"www.zhz.gift/tags/算法/"}]},{"title":"希尔排序","slug":"希尔排序","date":"2017-11-20T15:57:35.000Z","updated":"2017-11-20T16:14:06.358Z","comments":true,"path":"2017/11/20/希尔排序/","link":"","permalink":"www.zhz.gift/2017/11/20/希尔排序/","excerpt":"希尔排序 希尔排序(ShellSort)的名称源于它的发明者Donald Shell.它通过比较相距一定间隔(h[k])的元素来工作,各躺比较所用的距离随着算法的进行而减小(h[k-1]),直到只比较相邻元素的最后一趟排序为止,因此希尔排序也称为缩减增量排序.希尔排序所使用的增量序列只要h[1]=1,任何增量序列都是可行的,但其时间复杂度会有所不同.","text":"希尔排序 希尔排序(ShellSort)的名称源于它的发明者Donald Shell.它通过比较相距一定间隔(h[k])的元素来工作,各躺比较所用的距离随着算法的进行而减小(h[k-1]),直到只比较相邻元素的最后一趟排序为止,因此希尔排序也称为缩减增量排序.希尔排序所使用的增量序列只要h[1]=1,任何增量序列都是可行的,但其时间复杂度会有所不同. import java.util.*; public class Test { public static void main(String[] args){ int[] test = new int[]{11,3,8,25,22}; Test.shellSort(test); } /** * 希尔排序,使用ht=N/2 hk=h(k+1)/2的增量序列 * @param a */ public static void shellSort(int[] a){ int hk; int j; for(hk = a.length / 2;hk &gt; 0 ;hk /= 2){ for(int k = hk;k &lt; a.length;k++){ int temp = a[k]; for(j = k;j &gt;= hk &amp;&amp; a[j - hk] &gt; temp;j -= hk){ a[j] = a[j- hk]; } a[j] = temp; } } System.out.println(Arrays.toString(a)); } } 不稳定算法 空间复杂度O(1)","categories":[],"tags":[{"name":"java","slug":"java","permalink":"www.zhz.gift/tags/java/"},{"name":"算法","slug":"算法","permalink":"www.zhz.gift/tags/算法/"}]},{"title":"插入排序","slug":"插入排序","date":"2017-11-20T15:52:15.000Z","updated":"2017-11-20T15:57:39.472Z","comments":true,"path":"2017/11/20/插入排序/","link":"","permalink":"www.zhz.gift/2017/11/20/插入排序/","excerpt":"插入排序 插入排序由N-1趟排序组成,对于p=1到N-1趟,插入排序保证从位置0到位置p上的元素为已排序状态.","text":"插入排序 插入排序由N-1趟排序组成,对于p=1到N-1趟,插入排序保证从位置0到位置p上的元素为已排序状态. import java.util.Arrays; public class InsertSort2 { public static void main(String[] args){ int[] a = new int[]{11,3,6,22,15}; sort(a); System.out.println(Arrays.toString(a)); } //插入排序： //将无序的元素插入到有序的元素序列中，插入后仍然有序 public static void sort(int[] a){ int k; for(int p = 1;p &lt; a.length;p++){ int temp = a[p]; for(k = p;k &gt; 0 &amp;&amp; a[k- 1] &gt; temp;k--){ a[k] = a[k- 1]; } a[k] = temp; } } } 最差时间复杂度:O(n^2) 平均时间复杂度O(n^2) 空间复杂度:O(1) 稳定算法","categories":[],"tags":[{"name":"java","slug":"java","permalink":"www.zhz.gift/tags/java/"},{"name":"算法","slug":"算法","permalink":"www.zhz.gift/tags/算法/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2017-11-20T15:14:53.000Z","updated":"2017-11-20T15:51:10.068Z","comments":true,"path":"2017/11/20/冒泡排序/","link":"","permalink":"www.zhz.gift/2017/11/20/冒泡排序/","excerpt":"冒泡排序","text":"冒泡排序 import java.util.Arrays; public class MTest { //冒泡排序： //比较相邻元素，直到序列变为有序为止 public static void main(String[] args){ int[] a = new int[]{7,2,8,11,3,5,4}; //int[] a = new int[]{1,2,3,4,5,6}; for(int i = 0;i &lt; a.length - 1;i++){ boolean flag =false; for(int k = 0;k &lt; a.length - 1 -i;k++){ if(a[k] &gt; a[k + 1]){ int temp = a[k]; a[k] = a[k + 1]; a[k + 1] = temp; flag = true; } } if(!flag){ break; } } System.out.println(Arrays.toString(a)); } } 每次循环对每对相邻元素依次进行比较,比较过后最后的元素也是最大的元素,重复n-1次即可得到有序序列最差时间复杂度:O(n^2) 平均时间复杂度O(n^2) 空间复杂度:O(1) 稳定算法","categories":[],"tags":[{"name":"java","slug":"java","permalink":"www.zhz.gift/tags/java/"},{"name":"算法","slug":"算法","permalink":"www.zhz.gift/tags/算法/"}]}]}