{"meta":{"title":"静默的魔法书","subtitle":"零","description":"A blog of Hans Chung","author":"Hans Chung","url":"www.zhz.gift/blog"},"pages":[{"title":"About Me","date":"2017-11-18T11:35:43.000Z","updated":"2017-11-18T11:58:26.965Z","comments":true,"path":"about/index.html","permalink":"www.zhz.gift/blog/about/index.html","excerpt":"","text":"I’m only a salty fish.. i will make more efforts.i promise..maybe"}],"posts":[{"title":"使用YAML代替Properties","slug":"使用YAML代替Properties","date":"2017-12-16T16:07:42.000Z","updated":"2017-12-17T12:12:19.322Z","comments":true,"path":"2017/12/17/使用YAML代替Properties/","link":"","permalink":"www.zhz.gift/blog/2017/12/17/使用YAML代替Properties/","excerpt":"使用YAML代替Properties","text":"使用YAML代替Properties ##SpringBoot支持YAML##YAML是JSON的一个超集，也是一种方便的定义层次配置数据的格式。只要你将SnakeYAML 库放到classpath下， SpringApplication 就会自动支持YAML，以作为properties的替换。注 如果你使用’Starters’，添加 spring-boot-starter 依赖会自动加载SnakeYAML。 ##加载YAML## Spring框架提供两个便利的类用于加载YAML文档，YamlPropertiesFactoryBean 会将YAML加载为 Properties ， YamlMapFactoryBean 会将YAML加载为 Map 。例如，下面的YAML文档： environments: dev: url: http://dev.bar.com name: Developer Setup prod: url: http://foo.bar.com name: My Cool App 会被转化到这些属性： environments.dev.url=http://dev.bar.com environments.dev.name=Developer Setup environments.prod.url=http://foo.bar.com environments.prod.name=My Cool App YAML列表被表示成使用[index]间接引用作为属性keys的形式，例如下面的YAML： my: servers: - dev.bar.com - foo.bar.com 将会转化到这些属性: my.servers[0]=dev.bar.com my.servers[1]=foo.bar.com 使用Spring DataBinder 工具集绑定这些属性（这是@ConfigurationProperties 做的事）时，你需要确保目标bean有个 java.util.List 或 Set 类型的属性，并且需要提供一个setter或使用可变的值初始化它，比如，下面的代码将绑定上面的属性： @ConfigurationProperties(prefix=&quot;my&quot;) public class Config { private List&lt;String&gt; servers = new ArrayList&lt;String&gt;(); public List&lt;String&gt; getServers(){ return this.servers; } } ##在Spring环境中使用YAML暴露属性## YamlPropertySourceLoader类能够将YAML作为PropertySource导出到SprigEnvironment ，这允许你使用常用的 @Value注解配合占位符语法访问YAML属性。 ##Multi-profile YAML文档## 你可以在单个文件中定义多个特定配置（profile-specific）的YAML文档，并通过 spring.profiles 标示生效的文档，例如： server: address: 192.168.1.100 --- spring: profiles: development server: address: 127.0.0.1 --- spring: profiles: production server: address: 192.168.1.120 在以上例子中，如果 development profile被激活， server.address 属性将是 127.0.0.1 ；如果 development 和 production profiles没有启用，则该属性的值将是 192.168.1.100 。在应用上下文启动时，如果没有明确指定激活的profiles，则默认的profiles将生效。所以，在下面的文档中我们为 security.user.password 设置了一个值，该值只在”default” profile中有效： server: port: 8000 --- spring: profiles: default security: user: password: weak 然而，在这个示例中，由于没有关联任何profile，密码总是会设置，并且如果有必要的话可以在其他profiles中显式重置： server: port: 8000 security: user: password: weak 通过 ! 可以对 spring.profiles指定的profiles进行取反（negated，跟java中的 ! 作用一样），如果negated和non-negated profiles都指定一个单一文件，至少需要匹配一个non-negated profile，可能不会匹配任何negated profiles。 ##YAML缺点## YAML文件不能通过 @PropertySource 注解加载，如果需要使用该方式，那就必须使用properties文件。 ##合并YAML列表## 正如上面看到的，所有YAML最终都转换为properties，在通过一个profile覆盖”list”属性时这个过程可能不够直观（counter intuitive）。例如，假设有一个 MyPojo 对象，默认它的 name 和 description 属性都为 null ，下面我们将从 FooProperties 暴露一个 MyPojo 对象列表（list）： @ConfigurationProperties(&quot;foo&quot;) public class FooProperties { private final List&lt;MyPojo&gt; list = new ArrayList&lt;&gt;(); public List&lt;MyPojo&gt; getList() { return this.list; } } 考虑如下配置： foo: list: - name: my name description: my description --- spring: profiles: dev foo: list: - name: my another name 如果 dev profile没有激活， FooProperties.list 将包括一个如上述定义的 MyPojo 实体，即使 dev 生效，该 list 仍旧只包含一个实体（ name 值为 my another name ，description 值为 null ）。此配置不会向该列表添加第二个 MyPojo 实例，也不会对该项进行合并。当一个集合定义在多个profiles时，只使用优先级最高的： foo: list: - name: my name description: my description - name: another name description: another description --- spring: profiles: dev foo: list: - name: my another name 在以上示例中，如果 dev profile激活， FooProperties.list将包含一个 MyPojo 实体（ name 值为 my another name ， description 值为 null ）。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"www.zhz.gift/blog/tags/SpringBoot/"},{"name":"YAML","slug":"YAML","permalink":"www.zhz.gift/blog/tags/YAML/"}]},{"title":"SpringBoot应用启动事件","slug":"SpringBoot应用启动事件","date":"2017-12-16T16:07:42.000Z","updated":"2017-12-17T12:10:53.646Z","comments":true,"path":"2017/12/17/SpringBoot应用启动事件/","link":"","permalink":"www.zhz.gift/blog/2017/12/17/SpringBoot应用启动事件/","excerpt":"SpringBoot应用启动事件","text":"SpringBoot应用启动事件 监听Spring boot应用的事件只需实现ApplicationListener接口来监听对应事件. 有些事件实际上是在 ApplicationContext 创建前触发的，所以你不能在那些 事件（处理类）中通过 @Bean 注册监听器，只能通 过 SpringApplication.addListeners(…) 或 SpringApplicationBuilder.lis teners(…) 方法注册. 应用运行时，事件会以下面的次序发送： 在运行开始，但除了监听器注册和初始化以外的任何处理之前，会发送一 个 ApplicationStartedEvent 。 在Environment将被用于已知的上下文，但在上下文被创建前，会发送一 个 ApplicationEnvironmentPreparedEvent 。 在refresh开始前，但在bean定义已被加载后，会发送一 个 ApplicationPreparedEvent 。 在refresh之后，相关的回调处理完，会发送一个 ApplicationReadyEvent ， 表示应用准备好接收请求了。 启动过程中如果出现异常，会发送一个 ApplicationFailedEvent 。 注 通常不需要使用application事件，但知道它们的存在是有用的（在某些场合可能 会使用到），比如，在Spring Boot内部会使用事件处理各种任务。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"www.zhz.gift/blog/tags/SpringBoot/"},{"name":"event","slug":"event","permalink":"www.zhz.gift/blog/tags/event/"}]},{"title":"使用CommandLineRunner或ApplicationRunner","slug":"使用CommandLineRunner或ApplicationRunner","date":"2017-12-16T16:07:42.000Z","updated":"2017-12-17T12:11:22.286Z","comments":true,"path":"2017/12/17/使用CommandLineRunner或ApplicationRunner/","link":"","permalink":"www.zhz.gift/blog/2017/12/17/使用CommandLineRunner或ApplicationRunner/","excerpt":"使用CommandLineRunner或ApplicationRunner","text":"使用CommandLineRunner或ApplicationRunner 如果需要在 SpringApplication 启动后执行一些特殊的代码，你可以实现 ApplicationRunner 或 CommandLineRunner 接口，这两个接口工作方式相同，都只提供单一的 run 方法，该方法仅在 SpringApplication.run(…) 完成之前调用。 CommandLineRunner 接口能够访问string数组类型的应用参数，而 ApplicationRunner 使用的是上面描述过的 ApplicationArguments 接口： import org.springframework.boot.* import org.springframework.stereotype.* @Component public class MyBean implements CommandLineRunner { public void run(String... args) { // Do something... } } 如果某些定义的 CommandLineRunner 或 ApplicationRunner beans需要以特定的顺序调用，你可以实现 org.springframework.core.Ordered 接口或使用 org.springframework.core.annotation.Order 注解。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"www.zhz.gift/blog/tags/SpringBoot/"}]},{"title":"SpringBoot日志","slug":"SpringBoot日志","date":"2017-12-16T16:07:42.000Z","updated":"2017-12-17T12:12:51.622Z","comments":true,"path":"2017/12/17/SpringBoot日志/","link":"","permalink":"www.zhz.gift/blog/2017/12/17/SpringBoot日志/","excerpt":"SpringBoot日志","text":"SpringBoot日志 ##日志格式## Spring Boot默认的日志输出格式如下： 2014-03-05 10:57:51.112 INFO 45469 --- [main]org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/7.0.522014-03-05 10:57:51.253 INFO 45469 --- [ost-startStop-1] o.a.c. c.C.[Tomcat].[localhost].[/] : Initializing Spring embedde d WebApplicationContext 2014-03-05 10:57:51.253 INFO 45469 --- [ost-startStop-1] o.s.we b.context.ContextLoader : Root WebApplicationContext: initialization completed in 1358 ms 2014-03-05 10:57:51.698 INFO 45469 --- [ost-startStop-1] o.s.b. c.e.ServletRegistrationBean : Mapping servlet: &apos;dispatche rServlet&apos; to [/] 2014-03-05 10:57:51.702 INFO 45469 --- [ost-startStop-1] o.s.b. c.embedded.FilterRegistrationBean : Mapping filter: &apos;hiddenHttp MethodFilter&apos; to: [/*] 输出的节点（items）如下： 日期和时间 - 精确到毫秒，且易于排序。 日志级别 - ERROR , WARN , INFO , DEBUG 或 TRACE 。 Process ID。 — 分隔符，用于区分实际日志信息开头。 线程名 - 包括在方括号中（控制台输出可能会被截断）。 日志名 - 通常是源class的类名（缩写）。 日志信息。注 Logback没有 FATAL 级别，它会映射到 ERROR 。 ##控制台输出## 默认的日志配置会在写日志消息时将它们回显到控制台，级别为 ERROR ,WARN 和 INFO 的消息会被记录。你可以在启动应用时，通过 –debug 标识开启控制台的DEBUG级别日志记录，也可以在application.properties 中指定 debug=true 。 $ java -jar myapp.jar --debug 当debug模式启用时，一系列核心loggers（内嵌容器，Hibernate，Spring Boot等）记录的日志会变多，但不会输出所有的信息。相应地，你可以在启动应用时，通过 –trace （或在 application.properties 设置 trace=true ）启用”trace”模式，该模式能够追踪核心loggers（内嵌容器，Hibernate生成的schema，Spring全部的portfolio）的所有日志信息。 ##文件输出## 默认情况下，SpringBoot只会将日志记录到控制台，而不写进日志文件，如果需要，你可以设置 logging.file 或 logging.path 属性（例如 application.properties ）。下表展示如何组合使用 logging.* ： logging.file logging.path 示例 描述 (none) (none) 只记录到控制台 Specific file (none) my.log 写到特定的日志文件，名称可以是精确的位置或相对于当前目录 (none) Specific directory /var/log 写到特定目录下的 spring.log 里，名称可以是精确的位置或相对于当前目录 日志文件每达到10M就会被分割，跟控制台一样，默认记录 ERROR ,WARN 和 INFO 级别的信息。 ##日志级别## 所有Spring Boot支持的日志系统都可以在Spring Environment 中设置级别（ application.properties 里也一样），设置格式为’logging.level.*=LEVEL’，其中 LEVEL 是 TRACE , DEBUG , INFO , WARN , ERROR , FATAL , OFF 之一：以下是 application.properties 示例： logging.level.root=WARN logging.level.org.springframework.web=DEBUG logging.level.org.hibernate=ERROR 注 默认情况，Spring Boot会重新映射Thymeleaf的 INFO 信息到 DEBUG 级别，这能减少标准日志输出的噪声。查看LevelRemappingAppender可以按自己的配置设置映射。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"www.zhz.gift/blog/tags/SpringBoot/"},{"name":"log","slug":"log","permalink":"www.zhz.gift/blog/tags/log/"}]},{"title":"Application属性文件","slug":"Application属性文件","date":"2017-12-16T16:07:42.000Z","updated":"2017-12-17T12:10:39.804Z","comments":true,"path":"2017/12/17/Application属性文件/","link":"","permalink":"www.zhz.gift/blog/2017/12/17/Application属性文件/","excerpt":"Application属性文件","text":"Application属性文件 SpringApplication 将从以下位置加载 application.properties 文件，并把它们添加到Spring Environment 中： 当前目录下的 /config 子目录。 当前目录。 classpath下的 /config 包。 classpath根路径（root）。 该列表是按优先级排序的（列表中位置高的路径下定义的属性将覆盖位置低的）。注 你可以使用YAML（’.yml’）文件替代’.properties’。 如果不喜欢将 application.properties 作为配置文件名，你可以通过指定 spring.config.name 环境属性来切换其他的名称，也可以使用 spring.config.location 环境属性引用一个明确的路径（目录位置或文件路径列表以逗号分割）。 $ java -jar myproject.jar --spring.config.name=myproject 或 $ java -jar myproject.jar --spring.config.location=classpath:/de fault.properties,classpath:/override.properties 注 在初期需要根据 spring.config.name 和 spring.config.location 决定加载哪个文件，所以它们必须定义为environment属性（通常为OS env，系统属性或命令行参数）。 如果 spring.config.location 包含目录（相对于文件），那它们应该以 / 结尾（在被加载前， spring.config.name 关联的名称将被追加到后面，包括profile-specific的文件名）。 spring.config.location 下定义的文件使用方法跟往常一样，没有profile-specific变量支持的属性，将被profile-specific的属性覆盖。 不管 spring.config.location 配置什么值，默认总会按照 classpath:,classpath:/config,file:,file:config/ 的顺序进行搜索，优先级由低到高，也就是 file:config/ 获胜。如果你指定自己的位置，它们会优先于所有的默认位置（locations），并使用相同的由低到高的优先级顺序。那样，你就可以在 application.properties 为应用设置默认值，然后在运行的时候使用不同的文件覆盖它，同时保留默认配置。 注 如果使用环境变量而不是系统属性，需要注意多数操作系统的key名称不允许以句号分割（period-separated），但你可以使用下划线（underscores）代替（比如，使用 SPRING_CONFIG_NAME 代替 spring.config.name ）。注 如果应用运行在容器中，那么JNDI属性（java:comp/env）或servlet上下文初始化参数可以用来代替环境变量或系统属性，当然也可以使用环境变量或系统属性。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"www.zhz.gift/blog/tags/SpringBoot/"}]},{"title":"Spring WebMVC框架","slug":"Spring_Web_MVC框架","date":"2017-12-16T16:07:42.000Z","updated":"2017-12-17T12:11:43.347Z","comments":true,"path":"2017/12/17/Spring_Web_MVC框架/","link":"","permalink":"www.zhz.gift/blog/2017/12/17/Spring_Web_MVC框架/","excerpt":"Spring WebMVC框架","text":"Spring WebMVC框架 Spring Web MVC框架（通常简称为”SpringMVC”）是一个富“模型，视图，控制器”web框架， 允许用户创建特定的 @Controller 或 @RestController beans来处理传入的HTTP请求，通过@RequestMapping注解可以将控制器中的方法映射到相应的HTTP请求。示例： @RestController @RequestMapping(value=&quot;/users&quot;) public class MyRestController { @RequestMapping(value=&quot;/{user}&quot;, method=RequestMethod.GET) public User getUser(@PathVariable Long user) { // ... } @RequestMapping(value=&quot;/{user}/customers&quot;, method=RequestMet hod.GET) List&lt;Customer&gt; getUserCustomers(@PathVariable Long user) { // ... } @RequestMapping(value=&quot;/{user}&quot;, method=RequestMethod.DELETE ) public User deleteUser(@PathVariable Long user) { // ... } } Spring MVC是Spring框架的核心部分，详细信息可以参考referencedocumentation，spring.io/guides也有一些可用的指导覆盖Spring MVC。 Spring MVC自动配置Spring Boot为Spring MVC提供的auto-configuration适用于大多数应用，并在Spring默认功能上添加了以下特性： 引入 ContentNegotiatingViewResolver 和 BeanNameViewResolverbeans。 对静态资源的支持，包括对WebJars的支持。 自动注册 Converter ， GenericConverter ， Formatter beans。 对 HttpMessageConverters 的支持。 自动注册 MessageCodeResolver 。 对静态 index.html 的支持。 对自定义 Favicon 的支持。 自动使用 ConfigurableWebBindingInitializer bean。 如果保留Spring Boot MVC特性，你只需添加其他的MVC配置（拦截器，格式化处理器，视图控制器等）。你可以添加自己的 WebMvcConfigurerAdapter 类型的@Configuration类，而不需要注解@EnableWebMvc。如果希望使用自定义的 RequestMappingHandlerMapping ，RequestMappingHandlerAdapter ，或 ExceptionHandlerExceptionResolver，你可以声明一个WebMvcRegistrationsAdapter 实例提供这些组件。 如果想全面控制Spring MVC，你可以添加自己的 @Configuration ，并使用 @EnableWebMvc 注解。 ##HttpMessageConverters## Spring MVC使用 HttpMessageConverter 接口转换HTTP请求和响应，合适的默认配置可以开箱即用，例如对象自动转换为JSON（使用Jackson库）或XML（如果Jackson XML扩展可用，否则使用JAXB），字符串默认使用 UTF-8 编码。可以使用Spring Boot的 HttpMessageConverters 类添加或自定义转换类： import org.springframework.boot.autoconfigure.web.HttpMessageCon verters; import org.springframework.context.annotation.*; import org.springframework.http.converter.*; @Configuration public class MyConfiguration { @Bean public HttpMessageConverters customConverters() { HttpMessageConverter&lt;?&gt; additional = ... HttpMessageConverter&lt;?&gt; another = ... return new HttpMessageConverters(additional, another); } } 上下文中出现的所有 HttpMessageConverter bean都将添加到converters列表，你可以通过这种方式覆盖默认的转换器列表（converters）。 ##自定义JSON序列化器和反序列化器## 如果使用Jackson序列化，反序列化JSON数据，你可能想编写自己的 JsonSerializer 和 JsonDeserializer 类。自定义序列化器（serializers）通常通过Module注册到Jackson，但Spring Boot提供了 @JsonComponent 注解这一替代方式，它能轻松的将序列化器注册为Spring Beans。 ##MessageCodesResolver## Spring MVC有一个实现策略，用于从绑定的errors产生用来渲染错误信息的错误码： MessageCodesResolver 。SpringBoot会自动为你创建该实现，只要设置spring.mvc.message-codes-resolver.format 属性为 PREFIX_ERROR_CODE 或 POSTFIX_ERROR_CODE （具体查看 DefaultMessageCodesResolver.Format 枚举值）。 ##静态内容## 默认情况下，Spring Boot从classpath下的 /static （ /public ， /resources 或 /META-INF/resources ）文件夹，或从ServletContext 根目录提供静态内容。 这是通过Spring MVC的 ResourceHttpRequestHandler 实现的，你可以自定义WebMvcConfigurerAdapter 并覆写addResourceHandlers 方法来改变该行为（加载静态文件）。 在单机web应用中，容器会启动默认的servlet，并用它加载 ServletContext 根目录下的内容以响应那些Spring不处理的请求。大多数情况下这都不会发生（除非你修改默认的MVC配置），因为Spring总能够通过 DispatcherServlet 处理这些请求。 你可以设置 spring.resources.staticLocations 属性自定义静态资源的位置（配置一系列目录位置代替默认的值），如果你这样做，默认的欢迎页面将从自定义位置加载，所以只要这些路径中的任何地方有一个 index.html ，它都会成为应用的主页。 此外，除了上述标准的静态资源位置，有个例外情况是Webjars内容。任何在 /webjars/** 路径下的资源都将从jar文件中提供，只要它们以Webjars的格式打包。 注 如果你的应用将被打包成jar，那就不要使用 src/main/webapp文件夹。尽管该文件夹是通常的标准格式，但它仅在打包成war的情况下起作用，在打包成jar时，多数构建工具都会默认忽略它。 Spring Boot也支持SpringMVC提供的高级资源处理特性，可用于清除缓存的静态资源或对WebJar使用版本无感知的URLs。 如果想使用针对WebJars版本无感知的URLs（version agnostic），只需要添加 webjars-locator 依赖，然后声明你的Webjar。以jQuery为例， “/webjars/jquery/dist/jquery.min.js” 实际为 “/webjars/jquery/x.y.z/dist/jquery.min.js” ， x.y.z为Webjar的版本。 注 如果使用JBoss，你需要声明 webjars-locator-jboss-vfs 依赖而不是 webjars-locator ，否则所有的Webjars将解析为 404 。 以下的配置为所有的静态资源提供一种缓存清除（cache busting）方案，实际上是将内容hash添加到URLs中，比如 ： spring.resources.chain.strategy.content.enabled=true spring.resources.chain.strategy.content.paths=/** 注 实现该功能的是 ResourceUrlEncodingFilter ，它在模板运行期会重写资源链接，Thymeleaf，Velocity和FreeMarker会自动配置该filter，JSP需要手动配置。其他模板引擎还没自动支持，不过你可以使用ResourceUrlProvider自定义模块宏或帮助类。当使用比如JavaScript模块加载器动态加载资源时，重命名文件是不行的，这也是提供其他策略并能结合使用的原因。下面是一个”fixed”策略，在URL中添加一个静态version字符串而不需要改变文件名： spring.resources.chain.strategy.content.enabled=true spring.resources.chain.strategy.content.paths=/** spring.resources.chain.strategy.fixed.enabled=true spring.resources.chain.strategy.fixed.paths=/js/lib/ spring.resources.chain.strategy.fixed.version=v12 使用以上策略，JavaScript模块加载器加载 “/js/lib/“下的文件时会使用一个固定的版本策略 “/v12/js/lib/mymodule.js” ，其他资源仍旧使用内容hash的方式 。 查看ResourceProperties获取更多支持的选项。注 该特性在一个专门的博文和Spring框架参考文档中有透彻描述。 ##ConfigurableWebBindingInitializer## Spring MVC使用 WebBindingInitializer 为每个特殊的请求初始化相应的WebDataBinder ，如果你创建自己的 ConfigurableWebBindingInitializer @Bean ，Spring Boot会自动配置Spring MVC使用它。 ##模板引擎## 正如REST web服务，你也可以使用Spring MVC提供动态HTML内容。Spring MVC支持各种各样的模板技术，包括Velocity, FreeMarker和JSPs，很多其他的模板引擎也提供它们自己的Spring MVC集成。 Spring Boot为以下的模板引擎提供自动配置支持： FreeMarker Groovy Thymeleaf Velocity（1.4已不再支持） Mustache 注：由于在内嵌servlet容器中使用JSPs存在一些已知的限制，所以建议尽量不使用它们。 使用以上引擎中的任何一种，并采用默认配置，则模块会从src/main/resources/templates 自动加载。 注：IntelliJ IDEA根据你运行应用的方式会对classpath进行不同的排序。在IDE里通过main方法运行应用，跟从Maven，或Gradle，或打包好的jar中运行相比会导致不同的顺序，这可能导致SpringBoot不能从classpath下成功地找到模板。如果遇到这个问题，你可以在IDE里重新对classpath进行排序，将模块的类和资源放到第一位。或者，你可以配置模块的前缀为 classpath*:/templates/ ，这样会查找classpath下的所有模板目录。 ##错误处理## Spring Boot默认提供一个 /error 映射用来以合适的方式处理所有的错误，并将它注册为servlet容器中全局的 错误页面。对于机器客户端（相对于浏览器而言，浏览器偏重于人的行为），它会产生一个具有详细错误，HTTP状态，异常信息的JSON响应。对于浏览器客户端，它会产生一个白色标签样式（whitelabel）的错误视图，该视图将以HTML格式显示同样的数据（可以添加一个解析为’error’的View来自定义它）。为了完全替换默认的行为，你可以实现 ErrorController ，并注册一个该类型的bean定义，或简单地添加一个 ErrorAttributes 类型的bean以使用现存的机制，只是替换显示的内容。 注 BasicErrorController 可以作为自定义 ErrorController 的基类，如果你想添加对新context type的处理（默认处理 text/html ），这会很有帮助。你只需要继承 BasicErrorController，添加一个public方法，并注解带有 produces 属性的 @RequestMapping，然后创建该新类型的bean。你也可以定义一个@ControllerAdvice去自定义某个特殊controller或exception类型的JSON文档： @ControllerAdvice(basePackageClasses = FooController.class) public class FooControllerAdvice extends ResponseEntityException Handler { @ExceptionHandler(YourException.class) @ResponseBody ResponseEntity&lt;?&gt; handleControllerException(HttpServletReque st request, Throwable ex) { HttpStatus status = getStatus(request); return new ResponseEntity&lt;&gt;(new CustomErrorType(status.v alue(), ex.getMessage()), status); } private HttpStatus getStatus(HttpServletRequest request) { Integer statusCode = (Integer) request.getAttribute(&quot;jav ax.servlet.error.status_code&quot;); if (statusCode == null) { return HttpStatus.INTERNAL_SERVER_ERROR; } return HttpStatus.valueOf(statusCode); } } 在以上示例中，如果跟 FooController相同package的某个controller抛出 YourException ，一个 CustomerErrorType 类型的POJO的json展示将代替 ErrorAttributes 展示。 自定义错误页面 如果想为某个给定的状态码展示一个自定义的HTML错误页面，你需要将文件添加到 /error 文件夹下。错误页面既可以是静态HTML（比如，任何静态资源文件夹下添加的），也可以是使用模板构建的，文件名必须是明确的状态码或一系列标签。 例如，映射 404 到一个静态HTML文件，你的目录结构可能如下： src/ +- main/ +- java/ | + &lt;source code&gt; +- resources/ +- public/ +- error/ | +- 404.html +- &lt;other public assets&gt; 使用FreeMarker模板映射所有 5xx 错误，你需要如下的目录结构： src/ +- main/ +- java/ | + &lt;source code&gt; +- resources/ +- templates/ +- error/ | +- 5xx.ftl +- &lt;other templates&gt; 对于更复杂的映射，你可以添加实现 ErrorViewResolver接口的beans： public class MyErrorViewResolver implements ErrorViewResolver { @Override public ModelAndViewresolveErrorView(HttpServletRequest requ est,HttpStatus status,Map&lt;String, Object&gt; model) { // Use the request or status to optionally return a Mode lAndView return ... } } 你也可以使用Spring MVC特性，比如@ExceptionHandler方法和@ControllerAdvice，ErrorController 将处理所有未处理的异常。 映射Spring MVC以外的错误页面 对于不使用Spring MVC的应用，你可以通过 ErrorPageRegistrar 接口直接注册 ErrorPages。该抽象直接工作于底层内嵌servlet容器，即使你没有SpringMVC的DispatcherServlet ，它们仍旧可以工作。 @Bean public ErrorPageRegistrar errorPageRegistrar(){ return new MyErrorPageRegistrar(); } // ... private static class MyErrorPageRegistrar implements ErrorPageRegistrar { @Override public void registerErrorPages(ErrorPageRegistry registry) { registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQU EST, &quot;/400&quot;)); } } 注.如果你注册一个 ErrorPage ，该页面需要被一个 Filter 处理（在一些非Spring web框架中很常见，比如Jersey，Wicket），那么该 Filter 需要明确注册为一个 ERROR 分发器（dispatcher），例如： @Bean public FilterRegistrationBean myFilter() { FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new MyFilter()); ... registration.setDispatcherTypes(EnumSet.allOf(DispatcherType .class)); return registration; } （默认的 FilterRegistrationBean 不包含 ERROR dispatcher类型）。 WebSphere应用服务器的错误处理当部署到一个servlet容器时，Spring Boot通过它的错误页面过滤器将带有错误状态的请求转发到恰当的错误页面。 request只有在response还没提交时才能转发（forwarded）到正确的错误页面，而WebSphere应用服务器8.0及后续版本默认情况会在servlet方法成功执行后提交response，你需要设置 com.ibm.ws.webcontainer.invokeFlushAfterService 属性为 false 来关闭该行为。 ##Spring HATEOAS## 如果正在开发基于超媒体的RESTful API，你可能需要Spring HATEOAS，而SpringBoot会为其提供自动配置，这在大多数应用中都运作良好。 自动配置取代了 @EnableHypermediaSupport ，只需注册一定数量的beans就能轻松构建基于超媒体的应用，这些beans包括 LinkDiscoverers （客户端支持）， ObjectMapper （用于将响应编排为想要的形式）。 ObjectMapper 可以根据 spring.jackson.* 属性或 Jackson2ObjectMapperBuilder bean进行自定义。 通过注解 @EnableHypermediaSupport ，你可以控制Spring HATEOAS的配置，但这会禁用上述 ObjectMapper 的自定义功能。 ##CORS支持## 跨域资源共享（CORS）是一个大多数浏览器都实现了的W3C标准，它允许你以灵活的方式指定跨域请求如何被授权，而不是采用那些不安全，性能低的方式，比如IFRAME或JSONP。 从4.2版本开始，Spring MVC对CORS提供开箱即用的支持。不用添加任何特殊配置，只需要在Spring Boot应用的controller方法上注解 @CrossOrigin ，并添加CORS配置。通过注册一个自定义 addCorsMappings(CorsRegistry) 方法的WebMvcConfigurer bean可以指定全局CORS配置： @Configuration public class MyConfiguration { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurerAdapter() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/api/**&quot;); } }; } }","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"www.zhz.gift/blog/tags/SpringBoot/"},{"name":"MVC","slug":"MVC","permalink":"www.zhz.gift/blog/tags/MVC/"}]},{"title":"WEB环境下进行单元测试","slug":"WEB环境下进行单元测试","date":"2017-12-16T16:07:42.000Z","updated":"2017-12-17T12:11:06.369Z","comments":true,"path":"2017/12/17/WEB环境下进行单元测试/","link":"","permalink":"www.zhz.gift/blog/2017/12/17/WEB环境下进行单元测试/","excerpt":"WEB环境下进行单元测试","text":"WEB环境下进行单元测试 SpringApplication 将尝试为你创建正确类型的 ApplicationContext ，默认情况下，根据你开发的是否为web应用决定使用 AnnotationConfigApplicationContext 或 AnnotationConfigEmbeddedWebApplicationContext 。用于确定是否为web环境的算法相当简单（判断是否存在某些类），你可以使用 setWebEnvironment(boolean webEnvironment) 覆盖默认行为。通过调用 setApplicationContextClass(…) ，你可以完全控制 ApplicationContext 的类型。注 在Junit测试中使用 SpringApplication ，调用 setWebEnvironment(false) 是很有意义的。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"www.zhz.gift/blog/tags/SpringBoot/"}]},{"title":"第三方配置","slug":"第三方配置","date":"2017-12-16T16:07:42.000Z","updated":"2017-12-17T12:12:37.019Z","comments":true,"path":"2017/12/17/第三方配置/","link":"","permalink":"www.zhz.gift/blog/2017/12/17/第三方配置/","excerpt":"第三方配置","text":"第三方配置 @ConfigurationProperties 不仅可以注解在类上，也可以注解在public @Bean 方法上，当你需要为不受控的第三方组件绑定属性时，该方法将非常有用。为了从 Environment属性中配置一个bean，你需要使用@ConfigurationProperties 注解该bean： @ConfigurationProperties(prefix = &quot;foo&quot;) @Bean public FooComponent fooComponent() { ... } 和上面 ConnectionSettings 的示例方式相同，所有以foo为前缀的属性定义都会被映射到 FooComponent 上。 ##Relaxed绑定## Spring Boot将 Environment 属性绑定到 @ConfigurationProperties beans时会使用一些宽松的规则，所以 Environment属性名和bean属性名不需要精确匹配。常见的示例中有用的包括虚线分割（比如， context-path 绑定到 contextPath ），将environment属性转为大写字母（比如， PORT 绑定 port ）。例如，给定以下 @ConfigurationProperties 类： @ConfigurationProperties(prefix=&quot;person&quot;) public class OwnerProperties { private String firstName; public String getFirstName() { return this.firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } } 下面的属性名都能使用： 属性 说明 person.firstName 标准驼峰规则 person.first-name 虚线表示，推荐用于 .properties 和 .yml文件中 person.first_name 下划线表示，用于 .properties 和 .yml 文件的可选格式 PERSON_FIRST_NAME 大写形式，使用系统环境变量时推荐 ##属性转换## 将外部应用配置绑定到 @ConfigurationProperties beans时，Spring会尝试将属性强制转换为正确的类型。如果需要自定义类型转换器，你可以提供一个ConversionService bean（bean id为 conversionService ），或自定义属性编辑器（通过 CustomEditorConfigurer bean），或自定义 Converters （bean定义时需要注解 @ConfigurationPropertiesBinding ）。 注 由于该bean在应用程序生命周期的早期就需要使用，所以确保限制你的 ConversionService使用的依赖。通常，在创建时期任何你需要的依赖可能都没完全初始化。 ##@ConfigurationProperties校验## Spring Boot将尝试校验外部配置，默认使用JSR-303（如果在classpath路径中），你只需要将JSR-303 javax.validation 约束注解添加到 @ConfigurationProperties 类上： @ConfigurationProperties(prefix=&quot;connection&quot;) public class ConnectionProperties { @NotNull private InetAddress remoteAddress; // ... getters and setters } 为了校验内嵌属性的值，你需要使用 @Valid 注解关联的字段以触发它的校验，例如： @ConfigurationProperties(prefix=&quot;connection&quot;) public class ConnectionProperties { @NotNull @Valid private RemoteAddress remoteAddress; // ... getters and setters public static class RemoteAddress { @NotEmpty public String hostname; // ... getters and setters } } 你也可以通过创建一个叫做 configurationPropertiesValidator 的bean来添加自定义的Spring Validator 。 @Bean 方法需要声明为 static ，因为配置属性校验器在应用程序生命周期中创建的比较早，将 @Bean 方法声明为 static 允许该bean在创建时不需要实例化 @Configuration 类，从而避免了早期实例化（early instantiation）的所有问题。相关的示例可以看这里。 注 spring-boot-actuator 模块包含一个暴露所有 @ConfigurationProperties beans的端点（endpoint），通过浏览器打开 /configprops 进行浏览，或使用等效的JMX端点，具体参考Production readyfeatures。 @ConfigurationProperties vs. @Value@Value 是Spring容器的一个核心特性，它没有提供跟type-safe ConfigurationProperties相同的特性。下面的表格总结了 @ConfigurationProperties 和 @Value 支持的特性： 特性 @ConfigurationProperties @Value Relaxed绑定 Yes No Meta-data支持 Yes No SpEL表达式 No Yes 如果你为自己的组件定义了一系列的配置keys，我们建议你将它们以@ConfigurationProperties 注解的POJO进行分组。由于 @Value 不支持relaxed绑定，所以如果你使用环境变量提供属性值的话，它就不是很好的选择。最后，尽管 @Value 可以写 SpEL表达式，但这些表达式不会处理来自Application属性文件的属性。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"www.zhz.gift/blog/tags/SpringBoot/"},{"name":"config","slug":"config","permalink":"www.zhz.gift/blog/tags/config/"}]},{"title":"spring boot简介","slug":"spring-boot简介","date":"2017-12-02T14:22:54.000Z","updated":"2017-12-03T10:38:50.690Z","comments":true,"path":"2017/12/02/spring-boot简介/","link":"","permalink":"www.zhz.gift/blog/2017/12/02/spring-boot简介/","excerpt":"spring boot spring boot 为所有spring框架开发者提供一种更加易于理解，更加便捷高效的开发方式；通过提供更为直观的spring平台和第三方依赖库，只需要极其少量的spring配置，便能部署运行spring boot应用。","text":"spring boot spring boot 为所有spring框架开发者提供一种更加易于理解，更加便捷高效的开发方式；通过提供更为直观的spring平台和第三方依赖库，只需要极其少量的spring配置，便能部署运行spring boot应用。 1.环境要求 Spring Boot 2.0.0.BUILD-SNAPSHOT 需要 Java 8 以及 Spring Framework 5.0.2.RELEASE 或者以上版本.当使用maven或者gradle构建spring boot时需要 Maven 3.2+ 或者 Gradle 4及其以上版本. 2.spring boot安装 2.1使用maven 构建spring boot应用 pom.xml配置: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- Add Spring repositories --&gt; &lt;!-- (you don&apos;t need this if you are using a .RELEASE version) --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/project&gt; 2.2安装Spring Boot CLI The Spring Boot CLI (Command Line Interface)是一个用于快速建立spring原型的命令行工具.通过它你能运行Groovy scripts,使用熟悉的类java语法。 使用CLI来运行spring boot不是必须的,但它是使spring应用运行起来的最快方法. 2.2.1 手动安装 你可以在spring 软件仓库下载Spring CLI spring-boot-cli-2.0.0.BUILD-SNAPSHOT-bin.zip spring-boot-cli-2.0.0.BUILD-SNAPSHOT-bin.tar.gz 2.2.2 通过SDKMAN安装 SDKMAN!(The Software Development Kit Manager)可以用来管理不同版本的二进制sdks,包括 Groovy和Spring Boot CLI.从sdkman.io获取SDKMAN!并且通过以下命令来安装Spring Boot $ sdk install springboot $ spring --version Spring Boot v2.0.0.BUILD-SNAPSHOT 上述的安装方式都会在本地建立一个名为dev的Spring实例,它指向你的安装路径,所以你每次重建Spring Boot时,spring 都会更新到最新. 你能通过以下命令看到它是如何进行的: $ sdk ls springboot ================================================================================ Available Springboot Versions ================================================================================ &gt; + dev * 2.0.0.BUILD-SNAPSHOT ================================================================================ + - local version * - installed &gt; - currently in use ================================================================================ 3.开发你首个Spring Boot 应用 这个章节描述了如何区开发一个\\”五脏俱全\\”的Spring Boot \\”Hello World!\\”应用.我们使用Maven来构建这个项目,因为大部分IDES都支持它. spring.ioweb网站包含很多”Getting Started”的spring boot教程,如果你需要解决一些特定的问题,首先查看这里. 开始之前首先检查jdk版本和maven版本是否满足要求 java -version mvn -v pom.xml 配置如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt; &lt;!-- (you don&apos;t need this if you are using a .RELEASE version) --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/project&gt; 3.2 Spring Boot提供了大量的”Starters”开始器使你能在classpath路径添加jars.我们普通的例子应用已经在POM的父节点使用 spring-boot-starter-parent . spring-boot-starter-parent是一个提供了众多有用Maven默认配置的特殊启动器.它同样提供了dependency-management配置使你能够为一些dependencies依赖省略 version 配置. 但你开发其它特殊类型的应用时可能需要使用到其它启动器(Starters),例如,当我们开发一个web应用时,我们添加spring-boot-starter-web 依赖.在那之前,我们可以通过以下命令查看依赖树: mvn dependency:tree 通过mvn dependency:tree命令我们可以查看项目的依赖树结构,你可以看到 spring-boot-starter-parent 本身没有提供其它依赖.通过编辑pom.xml添加必要的依赖 org.springframework.boot spring-boot-starter-web 如果你再次运行 mvn dependency:tree 命令,你就能看到一系列新添加的依赖,包括tomcat 服务器以及spring boot本身. 3.3 代码编写 为了完成应用，我们首先需要创建一个java文件.在src/main/java下创建Example.java文件并添加以下代码: import org.springframework.boot.*; import org.springframework.boot.autoconfigure.*; import org.springframework.web.bind.annotation.*; @RestController @EnableAutoConfiguration public class Example { @RequestMapping(&quot;/&quot;) String home() { return &quot;Hello World!&quot;; } public static void main(String[] args) throws Exception { SpringApplication.run(Example.class, args); } } 3.3.1 @RestController 和 @RequestMapping 注解","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"www.zhz.gift/blog/tags/spring/"},{"name":"框架","slug":"框架","permalink":"www.zhz.gift/blog/tags/框架/"}]},{"title":"快速排序","slug":"快速排序","date":"2017-12-01T16:24:16.000Z","updated":"2017-12-01T16:24:49.088Z","comments":true,"path":"2017/12/02/快速排序/","link":"","permalink":"www.zhz.gift/blog/2017/12/02/快速排序/","excerpt":"快速排序 堆排序是指利用堆这种数据结构所设计的一种排序算法.堆是一种特殊的二叉树,每个子节点的值总是小于(或大于)它的父节点,相应的分为最大堆或最小堆,通过最大堆或最小堆不断输出堆顶元素,直到全部元素都已输出,得到的输出元素序列即为有序序列.","text":"快速排序 堆排序是指利用堆这种数据结构所设计的一种排序算法.堆是一种特殊的二叉树,每个子节点的值总是小于(或大于)它的父节点,相应的分为最大堆或最小堆,通过最大堆或最小堆不断输出堆顶元素,直到全部元素都已输出,得到的输出元素序列即为有序序列.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"www.zhz.gift/blog/tags/java/"},{"name":"算法","slug":"算法","permalink":"www.zhz.gift/blog/tags/算法/"}]},{"title":"堆排序","slug":"堆排序","date":"2017-11-30T16:07:42.000Z","updated":"2017-11-30T16:53:14.523Z","comments":true,"path":"2017/12/01/堆排序/","link":"","permalink":"www.zhz.gift/blog/2017/12/01/堆排序/","excerpt":"堆排序 堆排序是指利用堆这种数据结构所设计的一种排序算法.堆是一种特殊的二叉树,每个子节点的值总是小于(或大于)它的父节点,相应的分为最大堆或最小堆,通过最大堆或最小堆不断输出堆顶元素,直到全部元素都已输出,得到的输出元素序列即为有序序列.","text":"堆排序 堆排序是指利用堆这种数据结构所设计的一种排序算法.堆是一种特殊的二叉树,每个子节点的值总是小于(或大于)它的父节点,相应的分为最大堆或最小堆,通过最大堆或最小堆不断输出堆顶元素,直到全部元素都已输出,得到的输出元素序列即为有序序列. import java.util.Arrays; public class HeapSort3 { public static void main(String[] args){ int[] test = new int[]{8,11,3,6,23,14,18,7,55,34}; System.out.println(&quot;初始数组:&quot; + Arrays.toString(test)); HeapSort3.heapSort(test); System.out.println(Arrays.toString(test)); } public static int leftChild(int child){ return child * 2 + 1; } public static void precDown(int[] a,int i,int n){ int child; int temp; for(temp = a[i];leftChild(i) &lt; n;i = child){ child = leftChild(i); if(i != n - 1 &amp;&amp; a[child] &lt; a[child + 1]){ child++; } if(a[i] &lt; a[child]){ a[i] = a[child]; } } a[i] = temp; } public static void swapReferences(int[] a,int index){ int temp = a[0]; a[0] = a[index]; a[index] = temp; } public static void heapSort(int[] a){ for(int i = a.length / 2;i &gt; 0;i--){ precDown(a,i,a.length - 1); } System.out.println(&quot;max二叉堆构建完毕:&quot; + Arrays.toString(a)); for(int k = a.length - 1;k &gt; 0;k--){ swapReferences(a,k); precDown(a,0,k); } } } 最差时间复杂度:O(N*logN),平均时间复杂度O(N*logN),空间复杂度:O(1),不稳定算法","categories":[],"tags":[{"name":"java","slug":"java","permalink":"www.zhz.gift/blog/tags/java/"},{"name":"算法","slug":"算法","permalink":"www.zhz.gift/blog/tags/算法/"}]},{"title":"归并排序","slug":"归并排序","date":"2017-11-20T16:15:34.000Z","updated":"2017-11-20T16:32:40.377Z","comments":true,"path":"2017/11/21/归并排序/","link":"","permalink":"www.zhz.gift/blog/2017/11/21/归并排序/","excerpt":"归并排序 将一个无序序列进行折半递归,直到得到单个元素的有序序列,然后递归的将折半后左右两边的有序序列依次进行合并,最终得到有序序列.","text":"归并排序 将一个无序序列进行折半递归,直到得到单个元素的有序序列,然后递归的将折半后左右两边的有序序列依次进行合并,最终得到有序序列. import java.util.Arrays; public class MergeSort { public static void main(String[] args){ int[] a = new int[]{11,2,5,15,23,44,24,8}; mergeSort(a); System.out.println(Arrays.toString(a)); } private static void mergeSort(int[] a,int[] tmpArray,int left,int right){ if(left &lt; right){ int center = (left + right) / 2; mergeSort(a,tmpArray,left,center); mergeSort(a,tmpArray,center + 1,right); merge(a,tmpArray,left,center + 1,right); } System.out.println(&quot;left:&quot; + left + &quot;,right:&quot; + right); } public static void mergeSort(int[] a){ int[] tmpArray = new int[a.length]; mergeSort(a,tmpArray,0,a.length - 1); } private static void merge(int[] a,int[] tmpArray,int leftPos,int rightPos,int rightEnd){ System.out.println(&quot;leftPos:&quot; + leftPos + &quot;,rightPos:&quot; + rightPos + &quot;,rightEnd:&quot; + rightEnd); int leftEnd = rightPos - 1; int tmpPos = leftPos; int numElements = rightEnd - leftPos + 1; //Main loop while(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd){ if(a[leftPos] &lt; a[rightPos]){ tmpArray[tmpPos++] = a[leftPos++]; }else{ tmpArray[tmpPos++] = a[rightPos++]; } } while(leftPos &lt;= leftEnd){ tmpArray[tmpPos++] = a[leftPos++]; } while(rightPos &lt;= rightEnd){ tmpArray[tmpPos++] = a[rightPos++]; } for(int i = 0;i &lt; numElements;i++,rightEnd--){ a[rightEnd] = tmpArray[rightEnd]; } } } 最差时间复杂度:O(N^2) 平均时间复杂度O(N*logN) 空间复杂度:O(N) 稳定算法","categories":[],"tags":[{"name":"java","slug":"java","permalink":"www.zhz.gift/blog/tags/java/"},{"name":"算法","slug":"算法","permalink":"www.zhz.gift/blog/tags/算法/"}]},{"title":"希尔排序","slug":"希尔排序","date":"2017-11-20T15:57:35.000Z","updated":"2017-11-20T16:14:06.358Z","comments":true,"path":"2017/11/20/希尔排序/","link":"","permalink":"www.zhz.gift/blog/2017/11/20/希尔排序/","excerpt":"希尔排序 希尔排序(ShellSort)的名称源于它的发明者Donald Shell.它通过比较相距一定间隔(h[k])的元素来工作,各躺比较所用的距离随着算法的进行而减小(h[k-1]),直到只比较相邻元素的最后一趟排序为止,因此希尔排序也称为缩减增量排序.希尔排序所使用的增量序列只要h[1]=1,任何增量序列都是可行的,但其时间复杂度会有所不同.","text":"希尔排序 希尔排序(ShellSort)的名称源于它的发明者Donald Shell.它通过比较相距一定间隔(h[k])的元素来工作,各躺比较所用的距离随着算法的进行而减小(h[k-1]),直到只比较相邻元素的最后一趟排序为止,因此希尔排序也称为缩减增量排序.希尔排序所使用的增量序列只要h[1]=1,任何增量序列都是可行的,但其时间复杂度会有所不同. import java.util.*; public class Test { public static void main(String[] args){ int[] test = new int[]{11,3,8,25,22}; Test.shellSort(test); } /** * 希尔排序,使用ht=N/2 hk=h(k+1)/2的增量序列 * @param a */ public static void shellSort(int[] a){ int hk; int j; for(hk = a.length / 2;hk &gt; 0 ;hk /= 2){ for(int k = hk;k &lt; a.length;k++){ int temp = a[k]; for(j = k;j &gt;= hk &amp;&amp; a[j - hk] &gt; temp;j -= hk){ a[j] = a[j- hk]; } a[j] = temp; } } System.out.println(Arrays.toString(a)); } } 不稳定算法 空间复杂度O(1)","categories":[],"tags":[{"name":"java","slug":"java","permalink":"www.zhz.gift/blog/tags/java/"},{"name":"算法","slug":"算法","permalink":"www.zhz.gift/blog/tags/算法/"}]},{"title":"插入排序","slug":"插入排序","date":"2017-11-20T15:52:15.000Z","updated":"2017-11-20T15:57:39.472Z","comments":true,"path":"2017/11/20/插入排序/","link":"","permalink":"www.zhz.gift/blog/2017/11/20/插入排序/","excerpt":"插入排序 插入排序由N-1趟排序组成,对于p=1到N-1趟,插入排序保证从位置0到位置p上的元素为已排序状态.","text":"插入排序 插入排序由N-1趟排序组成,对于p=1到N-1趟,插入排序保证从位置0到位置p上的元素为已排序状态. import java.util.Arrays; public class InsertSort2 { public static void main(String[] args){ int[] a = new int[]{11,3,6,22,15}; sort(a); System.out.println(Arrays.toString(a)); } //插入排序： //将无序的元素插入到有序的元素序列中，插入后仍然有序 public static void sort(int[] a){ int k; for(int p = 1;p &lt; a.length;p++){ int temp = a[p]; for(k = p;k &gt; 0 &amp;&amp; a[k- 1] &gt; temp;k--){ a[k] = a[k- 1]; } a[k] = temp; } } } 最差时间复杂度:O(n^2) 平均时间复杂度O(n^2) 空间复杂度:O(1) 稳定算法","categories":[],"tags":[{"name":"java","slug":"java","permalink":"www.zhz.gift/blog/tags/java/"},{"name":"算法","slug":"算法","permalink":"www.zhz.gift/blog/tags/算法/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2017-11-20T15:14:53.000Z","updated":"2017-11-20T15:51:10.068Z","comments":true,"path":"2017/11/20/冒泡排序/","link":"","permalink":"www.zhz.gift/blog/2017/11/20/冒泡排序/","excerpt":"冒泡排序","text":"冒泡排序 import java.util.Arrays; public class MTest { //冒泡排序： //比较相邻元素，直到序列变为有序为止 public static void main(String[] args){ int[] a = new int[]{7,2,8,11,3,5,4}; //int[] a = new int[]{1,2,3,4,5,6}; for(int i = 0;i &lt; a.length - 1;i++){ boolean flag =false; for(int k = 0;k &lt; a.length - 1 -i;k++){ if(a[k] &gt; a[k + 1]){ int temp = a[k]; a[k] = a[k + 1]; a[k + 1] = temp; flag = true; } } if(!flag){ break; } } System.out.println(Arrays.toString(a)); } } 每次循环对每对相邻元素依次进行比较,比较过后最后的元素也是最大的元素,重复n-1次即可得到有序序列最差时间复杂度:O(n^2) 平均时间复杂度O(n^2) 空间复杂度:O(1) 稳定算法","categories":[],"tags":[{"name":"java","slug":"java","permalink":"www.zhz.gift/blog/tags/java/"},{"name":"算法","slug":"算法","permalink":"www.zhz.gift/blog/tags/算法/"}]}]}