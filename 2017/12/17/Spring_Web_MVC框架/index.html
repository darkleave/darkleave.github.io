<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Spring WebMVC框架 | 静默的魔法书</title>
  <meta name="description" content="A blog of Hans Chung" />
  <meta name="keywords" content="blog,Hans Chung,IT,钟汉忠,darkleave,java" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/blog/images/favicon.ico">
  <link rel="alternate" href="/blog/atom.xml" title="静默的魔法书">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Spring WebMVC框架">
<meta name="keywords" content="SpringBoot,MVC">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring WebMVC框架">
<meta property="og:url" content="www.zhz.gift/blog/2017/12/17/Spring_Web_MVC框架/index.html">
<meta property="og:site_name" content="静默的魔法书">
<meta property="og:description" content="Spring WebMVC框架">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-12-17T12:11:43.347Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring WebMVC框架">
<meta name="twitter:description" content="Spring WebMVC框架">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/blog/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/blog/' >
				静默的魔法书
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/blog/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/blog/archives'>
								Archives
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/blog/about'>
								About
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/blog/" class="nav-home nav">
				Home
			</a>
		
			<a href="/blog/archives" class="nav-archives nav">
				Archives
			</a>
		
			<a href="/blog/about" class="nav-about nav">
				About
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-Spring_Web_MVC框架"
  class="post white-box article-type-post"
  itemscope itemprop="blogPost">
	<section class='meta'>
	<h2 class="title">
  	<a href="/blog/2017/12/17/Spring_Web_MVC框架/">
    	Spring WebMVC框架
    </a>
  </h2>
	<time>
	  12月 17, 2017
	</time>
	
	</section>
	
		<section class="toc-wrapper"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC自动配置"><span class="toc-number">1.</span> <span class="toc-text">Spring    MVC自动配置</span></a></li></ol></section>
	
	<section class="article typo">
  	<div class="article-entry" itemprop="articleBody">
    	<p><strong>Spring WebMVC框架</strong></p>
<a id="more"></a>
<p>Spring    Web    MVC框架（通常简称为”SpringMVC”）是一个富“模型，视图，控制器”web框架，    允许用户创建特定的     @Controller    或     @RestController        beans来处理传入的HTTP请求，通过@RequestMapping注解可以将控制器中的方法映射到相应的HTTP请求。<br>示例：</p>
<pre><code>@RestController
@RequestMapping(value=&quot;/users&quot;)
public    class    MyRestController    {
                @RequestMapping(value=&quot;/{user}&quot;,    method=RequestMethod.GET)
                public    User    getUser(@PathVariable    Long    user)    {
                                //    ...
                }
                @RequestMapping(value=&quot;/{user}/customers&quot;,    method=RequestMet
hod.GET)
                List&lt;Customer&gt;    getUserCustomers(@PathVariable    Long    user)    {
                                //    ...
                }
                @RequestMapping(value=&quot;/{user}&quot;,    method=RequestMethod.DELETE
)
                public    User    deleteUser(@PathVariable    Long    user)    {
                                //    ...
                }
}
</code></pre><p>Spring    MVC是Spring框架的核心部分，详细信息可以参考reference<br>documentation，spring.io/guides也有一些可用的指导覆盖Spring    MVC。</p>
<h2 id="Spring-MVC自动配置"><a href="#Spring-MVC自动配置" class="headerlink" title="Spring    MVC自动配置"></a>Spring    MVC自动配置</h2><p>Spring    Boot为Spring    MVC提供的auto-configuration适用于大多数应用，并在<br>Spring默认功能上添加了以下特性：</p>
<ol>
<li>引入     ContentNegotiatingViewResolver    和     BeanNameViewResolver<br>beans。</li>
<li>对静态资源的支持，包括对WebJars的支持。</li>
<li>自动注册     Converter    ，     GenericConverter    ，     Formatter        beans。</li>
<li>对     HttpMessageConverters    的支持。</li>
<li>自动注册     MessageCodeResolver    。</li>
<li>对静态     index.html    的支持。</li>
<li>对自定义     Favicon    的支持。</li>
<li>自动使用     ConfigurableWebBindingInitializer        bean。</li>
</ol>
<p>如果保留Spring    Boot    MVC特性，你只需添加其他的MVC配置（拦截器，格式化处理器，视图控制器等）。你可以添加自己的     WebMvcConfigurerAdapter    类型的@Configuration类，而不需要注解@EnableWebMvc。如果希望使用自定义的     RequestMappingHandlerMapping    ，RequestMappingHandlerAdapter    ，或     ExceptionHandlerExceptionResolver，你可以声明一个WebMvcRegistrationsAdapter    实例提供这些组件。</p>
<p>如果想全面控制Spring    MVC，你可以添加自己的     @Configuration    ，并使用     @EnableWebMvc    注解。</p>
<p>##HttpMessageConverters##</p>
<p>Spring    MVC使用     HttpMessageConverter    接口转换HTTP请求和响应，合适的默认配置可以开箱即用，例如对象自动转换为JSON（使用Jackson库）或XML（如果Jackson XML扩展可用，否则使用JAXB），字符串默认使用     UTF-8    编码。<br>可以使用Spring    Boot的     HttpMessageConverters    类添加或自定义转换类：</p>
<pre><code>import    org.springframework.boot.autoconfigure.web.HttpMessageCon
verters;
import    org.springframework.context.annotation.*;
import    org.springframework.http.converter.*;
@Configuration
public    class    MyConfiguration    {
                @Bean
                public    HttpMessageConverters    customConverters()    {
                                HttpMessageConverter&lt;?&gt;    additional    =    ...
                                HttpMessageConverter&lt;?&gt;    another    =    ...
                                return    new    HttpMessageConverters(additional,    another);
                }
}
</code></pre><p>上下文中出现的所有     HttpMessageConverter        bean都将添加到converters列表，你可以通过这种方式覆盖默认的转换器列表（converters）。    </p>
<p>##自定义JSON序列化器和反序列化器##</p>
<p>如果使用Jackson序列化，反序列化JSON数据，你可能想编写自己的     JsonSerializer    和     JsonDeserializer    类。自定义序列化器（serializers）通常通过Module注册到Jackson，但Spring    Boot提供了     @JsonComponent    注解这一替代方式，它能轻松的将序列化器注册为Spring    Beans。</p>
<p>##MessageCodesResolver##</p>
<p>Spring    MVC有一个实现策略，用于从绑定的errors产生用来渲染错误信息的错误码：     MessageCodesResolver    。SpringBoot会自动为你创建该实现，只要设置spring.mvc.message-codes-resolver.format    属性为     PREFIX_ERROR_CODE    或     POSTFIX_ERROR_CODE    （具体查看     DefaultMessageCodesResolver.Format    枚举值）。</p>
<p>##静态内容##</p>
<p>默认情况下，Spring    Boot从classpath下的     /static    （     /public    ，     /resources    或     /META-INF/resources    ）文件夹，或从ServletContext    根目录提供静态内容。</p>
<p>这是通过Spring    MVC的     ResourceHttpRequestHandler    实现的，你可以自定义WebMvcConfigurerAdapter    并覆写addResourceHandlers    方法来改变该行为（加载静态文件）。</p>
<p>在单机web应用中，容器会启动默认的servlet，并用它加载     ServletContext    根目录下的内容以响应那些Spring不处理的请求。大多数情况下这都不会发生（除非你修改默认的MVC配置），因为Spring总能够通过     DispatcherServlet    处理这些请求。</p>
<p>你可以设置     spring.resources.staticLocations    属性自定义静态资源的位置（配置一系列目录位置代替默认的值），如果你这样做，默认的欢迎页面将从自定义位置加载，所以只要这些路径中的任何地方有一个     index.html    ，它都会成为应用的主页。</p>
<p>此外，除了上述标准的静态资源位置，有个例外情况是Webjars内容。任何在 /webjars/**    路径下的资源都将从jar文件中提供，只要它们以Webjars的格式<br>打包。</p>
<p>注    如果你的应用将被打包成jar，那就不要使用     src/main/webapp文件夹。尽管该文件夹是通常的标准格式，但它仅在打包成war的情况下起作用，在打包成jar时，多数构建工具都会默认忽略它。</p>
<p>Spring    Boot也支持SpringMVC提供的高级资源处理特性，可用于清除缓存的静态资源或对WebJar使用版本无感知的URLs。</p>
<p>如果想使用针对WebJars版本无感知的URLs（version    agnostic），只需要添<br>加     webjars-locator    依赖，然后声明你的Webjar。以jQuery为例，     “/webjars/jquery/dist/jquery.min.js”    实际<br>为     “/webjars/jquery/x.y.z/dist/jquery.min.js”    ，     x.y.z为Webjar的版<br>本。</p>
<p>注    如果使用JBoss，你需要声明     webjars-locator-jboss-vfs    依赖而不是     webjars-locator    ，否则所有的Webjars将解析为     404    。</p>
<p>以下的配置为所有的静态资源提供一种缓存清除（cache    busting）方案，实际上是<br>将内容hash添加到URLs中，比如     <link href="/css/spring-
2a2d595e6ed9a0b24f027f2b63b134d6.css">    ：</p>
<pre><code>spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
</code></pre><p>注    实现该功能的是     ResourceUrlEncodingFilter    ，它在模板运行期会重写资源链接，Thymeleaf，Velocity和FreeMarker会自动配置该filter，JSP需要手动配置。<br>其他模板引擎还没自动支持，不过你可以使用ResourceUrlProvider自定义模块宏或<br>帮助类。<br>当使用比如JavaScript模块加载器动态加载资源时，重命名文件是不行的，这也是提供其他策略并能结合使用的原因。下面是一个”fixed”策略，在URL中添加一个静态version字符串而不需要改变文件名：    </p>
<pre><code>spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
spring.resources.chain.strategy.fixed.enabled=true
spring.resources.chain.strategy.fixed.paths=/js/lib/
spring.resources.chain.strategy.fixed.version=v12
</code></pre><p>使用以上策略，JavaScript模块加载器加载     “/js/lib/“下的文件时会使用一个固定的版本策略     “/v12/js/lib/mymodule.js”    ，其他资源仍旧使用内容hash的方式     <link href="/css/spring-
2a2d595e6ed9a0b24f027f2b63b134d6.css">    。</p>
<p>查看ResourceProperties获取更多支持的选项。<br>注    该特性在一个专门的博文和Spring框架参考文档中有透彻描述。    </p>
<p>##ConfigurableWebBindingInitializer##</p>
<p>Spring    MVC使用     WebBindingInitializer    为每个特殊的请求初始化相应的WebDataBinder    ，如果你创建自己的     ConfigurableWebBindingInitializer @Bean    ，Spring    Boot会自动配置Spring    MVC使用它。</p>
<p>##模板引擎##</p>
<p>正如REST    web服务，你也可以使用Spring    MVC提供动态HTML内容。Spring    MVC<br>支持各种各样的模板技术，包括Velocity,    FreeMarker和JSPs，很多其他的模板引擎也提供它们自己的Spring    MVC集成。</p>
<p>Spring    Boot为以下的模板引擎提供自动配置支持：</p>
<ol>
<li>FreeMarker</li>
<li>Groovy</li>
<li>Thymeleaf</li>
<li>Velocity（1.4已不再支持）</li>
<li>Mustache</li>
<li>注：由于在内嵌servlet容器中使用JSPs存在一些已知的限制，所以建议尽量不使用它们。</li>
</ol>
<p>使用以上引擎中的任何一种，并采用默认配置，则模块会从src/main/resources/templates    自动加载。</p>
<p>注：IntelliJ    IDEA根据你运行应用的方式会对classpath进行不同的排序。<br>在IDE里通过main方法运行应用，跟从Maven，或Gradle，或打包好的jar中运行相比会导致不同的顺序，这可能导致SpringBoot不能从classpath下成功地找到模板。<br>如果遇到这个问题，你可以在IDE里重新对classpath进行排序，将模块的类和资源放到第一位。<br>或者，你可以配置模块的前缀为     classpath*:/templates/    ，这样会查找<br>classpath下的所有模板目录。</p>
<p>##错误处理##</p>
<p>Spring    Boot默认提供一个     /error    映射用来以合适的方式处理所有的错误，并将它注册为servlet容器中全局的    错误页面。<br>对于机器客户端（相对于浏览器而言，浏览器偏重于人的行为），它会产生一个具有详细错误，HTTP状态，异常信息的JSON响应。对于浏览器客户端，它会产生一个白色标签样式（whitelabel）的错误视图，该视图将以HTML格式显示同样的数据（可以添加一个解析为’error’的View来自定义它）。<br>为了完全替换默认的行为，你可以实现     ErrorController    ，并注册一个该类型的bean定义，或简单地添加一个     ErrorAttributes    类型的bean以使用现存的机制，只是替换显示的内容。</p>
<p>注          BasicErrorController    可以作为自定义     ErrorController    的基类，如果你想添加对新context    type的处理（默认处理     text/html    ），这会很有帮助。<br>你只需要继承     BasicErrorController，添加一个public方法，并注解带有     produces    属性的     @RequestMapping，然后创建该新类型的bean。<br>你也可以定义一个@ControllerAdvice去自定义某个特殊controller或exception类型的JSON文档：</p>
<pre><code>@ControllerAdvice(basePackageClasses    =    FooController.class)
public    class    FooControllerAdvice    extends    ResponseEntityException
Handler    {
                @ExceptionHandler(YourException.class)
                @ResponseBody
                ResponseEntity&lt;?&gt;    handleControllerException(HttpServletReque
st    request,    Throwable    ex)    {
                                HttpStatus    status    =    getStatus(request);
                                return    new    ResponseEntity&lt;&gt;(new    CustomErrorType(status.v
alue(),    ex.getMessage()),    status);
                }
                private    HttpStatus    getStatus(HttpServletRequest    request)    {
                                Integer    statusCode    =    (Integer)    request.getAttribute(&quot;jav
ax.servlet.error.status_code&quot;);
                                if    (statusCode    ==    null)    {
                                                return    HttpStatus.INTERNAL_SERVER_ERROR;
                                }
                                return    HttpStatus.valueOf(statusCode);
                }
}
</code></pre><p>在以上示例中，如果跟     FooController相同package的某个controller抛出     YourException    ，一个     CustomerErrorType    类型的POJO的json展示将代替     ErrorAttributes    展示。</p>
<p>自定义错误页面</p>
<p>如果想为某个给定的状态码展示一个自定义的HTML错误页面，你需要将文件添加到     /error    文件夹下。错误页面既可以是静态HTML（比如，任何静态资源文件夹下添加的），也可以是使用模板构建的，文件名必须是明确的状态码或一系列标签。</p>
<p>例如，映射     404    到一个静态HTML文件，你的目录结构可能如下：    </p>
<pre><code>src/
    +-    main/
            +-    java/
            |            +    &lt;source    code&gt;
            +-    resources/
                        +-    public/
                            +-    error/
                                |    +-    404.html
                            +-    &lt;other    public    assets&gt;    
</code></pre><p>使用FreeMarker模板映射所有     5xx    错误，你需要如下的目录结构：</p>
<pre><code>src/
    +-    main/
            +-    java/
            |            +    &lt;source    code&gt;
            +-    resources/
                    +-    templates/
                            +-    error/
                            |            +-    5xx.ftl
                            +-    &lt;other    templates&gt;
</code></pre><p>对于更复杂的映射，你可以添加实现     ErrorViewResolver接口的beans：</p>
<pre><code>public    class    MyErrorViewResolver    implements    ErrorViewResolver    {
                @Override
    public    ModelAndViewresolveErrorView(HttpServletRequest    requ
est,HttpStatus    status,Map&lt;String,    Object&gt;    model)    {
    //    Use    the    request    or    status    to    optionally    return    a    Mode
lAndView
                    return    ...
    }
}
</code></pre><p>你也可以使用Spring    MVC特性，比如@ExceptionHandler方法和@ControllerAdvice，ErrorController    将处理所有未处理的异常。</p>
<p>映射Spring    MVC以外的错误页面</p>
<p>对于不使用Spring    MVC的应用，你可以通过     ErrorPageRegistrar    接口直接注册     ErrorPages。<br>该抽象直接工作于底层内嵌servlet容器，即使你没有SpringMVC的DispatcherServlet    ，它们仍旧可以工作。    </p>
<pre><code>@Bean
public    ErrorPageRegistrar    errorPageRegistrar(){
                return    new    MyErrorPageRegistrar();
}
//    ...
private    static    class    MyErrorPageRegistrar    implements    ErrorPageRegistrar    {
                @Override
                public    void    registerErrorPages(ErrorPageRegistry    registry)    {
                                registry.addErrorPages(new    ErrorPage(HttpStatus.BAD_REQU
EST,    &quot;/400&quot;));
                }
}
</code></pre><p>注.如果你注册一个     ErrorPage    ，该页面需要被一个     Filter    处理（在一些非Spring    web框架中很常见，比如Jersey，Wicket），那么该     Filter    需要明确注册为一个     ERROR    分发器（dispatcher），例如：    </p>
<pre><code>@Bean
public    FilterRegistrationBean    myFilter()    {
                FilterRegistrationBean    registration    =    new    FilterRegistrationBean();
                registration.setFilter(new    MyFilter());
                ...
                registration.setDispatcherTypes(EnumSet.allOf(DispatcherType
.class));
                return    registration;
}
</code></pre><p>（默认的     FilterRegistrationBean    不包含     ERROR        dispatcher类型）。</p>
<p>WebSphere应用服务器的错误处理当部署到一个servlet容器时，Spring    Boot通过它的错误页面过滤器将带有错误状态的请求转发到恰当的错误页面。</p>
<p>request只有在response还没提交时才能转发（forwarded）到正确的错误页面，而WebSphere应用服务器8.0及后续版本默认情况会在servlet方法成功执行后提交response，你需要设置     com.ibm.ws.webcontainer.invokeFlushAfterService    属性为     false    来关闭该行为。    </p>
<p>##Spring HATEOAS##</p>
<p>如果正在开发基于超媒体的RESTful    API，你可能需要Spring    HATEOAS，而Spring<br>Boot会为其提供自动配置，这在大多数应用中都运作良好。</p>
<p>自动配置取代了     @EnableHypermediaSupport    ，只需注册一定数量的beans就能轻松构建基于超媒体的应用，这些beans包括     LinkDiscoverers    （客户端支持），     ObjectMapper    （用于将响应编排为想要的形式）。</p>
<p>ObjectMapper    可以根据     spring.jackson.*    属性或     Jackson2ObjectMapperBuilder        bean进行自定义。</p>
<p>通过注解     @EnableHypermediaSupport    ，你可以控制Spring    HATEOAS的配置，<br>但这会禁用上述     ObjectMapper    的自定义功能。</p>
<p>##CORS支持##</p>
<p>跨域资源共享（CORS）是一个大多数浏览器都实现了的W3C标准，它允许你以灵活的方式指定跨域请求如何被授权，而不是采用那些不安全，性能低的方式，比如IFRAME或JSONP。</p>
<p>从4.2版本开始，Spring MVC对CORS提供开箱即用的支持。不用添加任何特殊配置，只需要在Spring    Boot应用的controller方法上注解     @CrossOrigin    ，并添加CORS配置。<br>通过注册一个自定义     addCorsMappings(CorsRegistry)    方法的WebMvcConfigurer        bean可以指定全局CORS配置：</p>
<pre><code>@Configuration
public    class    MyConfiguration    {
            @Bean
            public    WebMvcConfigurer    corsConfigurer()    {
                                return    new    WebMvcConfigurerAdapter()    {
                                                @Override
            public    void    addCorsMappings(CorsRegistry    registry)    {
                                                                registry.addMapping(&quot;/api/**&quot;);
                                                }
                                };
            }
}
</code></pre>
  	</div>
	  
	  <div class="article-tags tags">
      
        <a href="/blog/tags/SpringBoot/">SpringBoot</a>
      
        <a href="/blog/tags/MVC/">MVC</a>
      
	  </div>
    
		
	
		<div class="art-item-footer">
				
					<span class="art-item-left"><i class="icon icon-chevron-thin-left"></i>prev：<a href="/blog/2017/12/17/Application属性文件/" rel="prev"  title="Application属性文件">
						Application属性文件 
					</a></span>
				
				
					<span class="art-item-right">next：<a href="/blog/2017/12/17/WEB环境下进行单元测试/" rel="next"  title="WEB环境下进行单元测试">
						WEB环境下进行单元测试
					</a><i class="icon icon-chevron-thin-right"></i></span>
				
		</div>
	
	</section>
	
</article>
<script>
	window.subData = {
		title: 'Spring WebMVC框架',
		tools: true
	}
</script>

      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='/blog/images/avatar.jpg' />

<div class='header'>Hans Chung</div>
<div class='content'>
<div class='desc'>Time is a bird for ever on the wing ...</div>
</div>
</section>

  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/blog/tags/MVC/" style="font-size: 14px; color: #808080">MVC</a> <a href="/blog/tags/SpringBoot/" style="font-size: 20px; color: #000">SpringBoot</a> <a href="/blog/tags/YAML/" style="font-size: 14px; color: #808080">YAML</a> <a href="/blog/tags/config/" style="font-size: 14px; color: #808080">config</a> <a href="/blog/tags/event/" style="font-size: 14px; color: #808080">event</a> <a href="/blog/tags/java/" style="font-size: 17px; color: #404040">java</a> <a href="/blog/tags/log/" style="font-size: 14px; color: #808080">log</a> <a href="/blog/tags/spring/" style="font-size: 14px; color: #808080">spring</a> <a href="/blog/tags/框架/" style="font-size: 14px; color: #808080">框架</a> <a href="/blog/tags/算法/" style="font-size: 17px; color: #404040">算法</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/darkleave" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/darkleave" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  <p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p>
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/blog/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/blog/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/blog/js/search.js"></script>
<script src="/blog/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
