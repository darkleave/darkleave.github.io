<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[使用YAML代替Properties]]></title>
      <url>/2017/12/17/%E4%BD%BF%E7%94%A8YAML%E4%BB%A3%E6%9B%BFProperties/</url>
      <content type="html"><![CDATA[<p><strong>使用YAML代替Properties</strong></p>
<a id="more"></a>
<p>##SpringBoot支持YAML##<br>YAML是JSON的一个超集，也是一种方便的定义层次配置数据的格式。只要你<br>将SnakeYAML    库放到classpath下，     SpringApplication    就会自动支持YAML，<br>以作为properties的替换。<br>注    如果你使用’Starters’，添加     spring-boot-starter    依赖会自动加载<br>SnakeYAML。</p>
<p>##加载YAML##</p>
<p>Spring框架提供两个便利的类用于加载YAML文档，YamlPropertiesFactoryBean    会将YAML加载为     Properties    ，     YamlMapFactoryBean    会将YAML加载为     Map    。<br>例如，下面的YAML文档：</p>
<pre><code>environments:
                dev:
                                url:    http://dev.bar.com
                                name:    Developer    Setup
                prod:
                                url:    http://foo.bar.com
                                name:    My    Cool    App
</code></pre><p>会被转化到这些属性：</p>
<pre><code>environments.dev.url=http://dev.bar.com
environments.dev.name=Developer    Setup
environments.prod.url=http://foo.bar.com
environments.prod.name=My    Cool    App
</code></pre><p>YAML列表被表示成使用[index]间接引用作为属性keys的形式，例如下面的<br>YAML：</p>
<pre><code>my:
            servers:
                            -    dev.bar.com
                            -    foo.bar.com
</code></pre><p>将会转化到这些属性:</p>
<pre><code>my.servers[0]=dev.bar.com
my.servers[1]=foo.bar.com
</code></pre><p>使用Spring          DataBinder    工具集绑定这些属性（这是@ConfigurationProperties    做的事）时，你需要确保目标bean有个     java.util.List    或     Set    类型的属性，并且需要提供一个setter或使用可变的值初始化它，比如，下面的代码将绑定上面的属性：</p>
<pre><code>@ConfigurationProperties(prefix=&quot;my&quot;)
public    class    Config    {
        private    List&lt;String&gt;    servers    =    new    ArrayList&lt;String&gt;();
        public    List&lt;String&gt;    getServers(){
                return    this.servers;
        }
}
</code></pre><p>##在Spring环境中使用YAML暴露属性##</p>
<p>YamlPropertySourceLoader类能够将YAML作为PropertySource导出到SprigEnvironment    ，这允许你使用常用的    @Value注解配合占位符语法访问YAML属<br>性。</p>
<p>##Multi-profile    YAML文档##</p>
<p>你可以在单个文件中定义多个特定配置（profile-specific）的YAML文档，并通过     spring.profiles    标示生效的文档，例如：</p>
<pre><code>server:
                address:    192.168.1.100
---
spring:
                profiles:    development
server:
                address:    127.0.0.1
---
spring:
                profiles:    production
server:
                address:    192.168.1.120
</code></pre><p>在以上例子中，如果     development        profile被激活，     server.address    属性将是     127.0.0.1    ；如果     development    和     production        profiles没有启用，则该属性的值将是     192.168.1.100    。<br>在应用上下文启动时，如果没有明确指定激活的profiles，则默认的profiles将生效。所以，在下面的文档中我们为     security.user.password    设置了一个值，该<br>值只在”default”    profile中有效：                    </p>
<pre><code>server:
        port:    8000
---
spring:
        profiles:    default
security:
        user:
                password:    weak
</code></pre><p>然而，在这个示例中，由于没有关联任何profile，密码总是会设置，并且如果有必要的话可以在其他profiles中显式重置：                    </p>
<pre><code>server:
        port:    8000
security:
        user:
                password:    weak                    
</code></pre><p>通过     !    可以对     spring.profiles指定的profiles进行取反（negated，跟java中的     !    作用一样），如果negated和non-negated    profiles都指定一个单一文件，至少需要匹配一个non-negated    profile，可能不会匹配任何negated    profiles。                    </p>
<p>##YAML缺点##                    </p>
<p>YAML文件不能通过     @PropertySource    注解加载，如果需要使用该方式，那就必须使用properties文件。</p>
<p>##合并YAML列表##</p>
<p>正如上面看到的，所有YAML最终都转换为properties，在通过一个profile覆<br>盖”list”属性时这个过程可能不够直观（counter    intuitive）。例如，假设有一<br>个     MyPojo    对象，默认它的     name    和     description    属性都为     null    ，下面我们<br>将从     FooProperties    暴露一个     MyPojo    对象列表（list）：</p>
<pre><code>@ConfigurationProperties(&quot;foo&quot;)
public    class    FooProperties    {
        private    final    List&lt;MyPojo&gt;    list    =    new    ArrayList&lt;&gt;();
        public    List&lt;MyPojo&gt;    getList()    {
                return    this.list;
        }
}
</code></pre><p>考虑如下配置：</p>
<pre><code>foo:
        list:
                -    name:    my    name
                        description:    my    description
---
spring:
        profiles:    dev
foo:
        list:
                -    name:    my    another    name
</code></pre><p> 如果     dev        profile没有激活，     FooProperties.list    将包括一个如上述定义的     MyPojo    实体，即使     dev    生效，该     list    仍旧只包含一个实体（     name    值为     my    another    name    ，description    值为     null    ）。<br>此配置不会向该列表添加第二个     MyPojo    实例，也不会对该项进行合并。<br>当一个集合定义在多个profiles时，只使用优先级最高的：       </p>
<pre><code>foo:
        list:
                -    name:    my    name
                        description:    my    description
                -    name:    another    name
                        description:    another    description
---
spring:
        profiles:    dev
foo:
        list:
                    -    name:    my    another    name
</code></pre><p> 在以上示例中，如果     dev        profile激活，     FooProperties.list将包含一个     MyPojo    实体（     name    值为     my    another    name    ，     description    值为     null    ）。   </p>
]]></content>
      
        
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> YAML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WEB环境下进行单元测试]]></title>
      <url>/2017/12/17/WEB%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p><strong>WEB环境下进行单元测试</strong></p>
<a id="more"></a>
<p> SpringApplication    将尝试为你创建正确类型的     ApplicationContext    ，默认<br>情况下，根据你开发的是否为web应用决定使<br>用     AnnotationConfigApplicationContext    或     AnnotationConfigEmbeddedWeb<br>ApplicationContext    。<br>用于确定是否为web环境的算法相当简单（判断是否存在某些类），你可以使<br>用     setWebEnvironment(boolean    webEnvironment)    覆盖默认行为。<br>通过调用     setApplicationContextClass(…)    ，你可以完全控<br>制     ApplicationContext    的类型。<br>注    在Junit测试中使用     SpringApplication    ，调<br>用     <strong>setWebEnvironment(false)</strong>    是很有意义的。</p>
]]></content>
      
        
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot应用启动事件]]></title>
      <url>/2017/12/17/SpringBoot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p><strong>SpringBoot应用启动事件</strong></p>
<a id="more"></a>
<p><strong>监听Spring boot应用的事件只需实现ApplicationListener接口来监听对应事件.</strong></p>
<p>有些事件实际上是在    ApplicationContext    创建前触发的，所以你不能在那些</p>
<p>事件（处理类）中通过    @Bean    注册监听器，只能通</p>
<p>过    SpringApplication.addListeners(…)    或    SpringApplicationBuilder.lis</p>
<p>teners(…)    方法注册.</p>
<p>应用运行时，事件会以下面的次序发送：</p>
<ol>
<li>在运行开始，但除了监听器注册和初始化以外的任何处理之前，会发送一</li>
</ol>
<p>个    ApplicationStartedEvent    。</p>
<ol>
<li>在Environment将被用于已知的上下文，但在上下文被创建前，会发送一</li>
</ol>
<p>个    ApplicationEnvironmentPreparedEvent    。</p>
<ol>
<li>在refresh开始前，但在bean定义已被加载后，会发送一</li>
</ol>
<p>个    ApplicationPreparedEvent    。</p>
<ol>
<li>在refresh之后，相关的回调处理完，会发送一个    ApplicationReadyEvent    ，</li>
</ol>
<p>表示应用准备好接收请求了。</p>
<ol>
<li>启动过程中如果出现异常，会发送一个    ApplicationFailedEvent    。</li>
</ol>
<p>注    通常不需要使用application事件，但知道它们的存在是有用的（在某些场合可能</p>
<p>会使用到），比如，在Spring    Boot内部会使用事件处理各种任务。</p>
]]></content>
      
        
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> event </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot日志]]></title>
      <url>/2017/12/17/SpringBoot%E6%97%A5%E5%BF%97/</url>
      <content type="html"><![CDATA[<p><strong>SpringBoot日志</strong></p>
<a id="more"></a>
<p>##日志格式##</p>
<p>Spring    Boot默认的日志输出格式如下：</p>
<pre><code>2014-03-05    10:57:51.112        INFO    45469    ---    [main]org.apache.catalina.core.StandardEngine        :    Starting    Servlet    Engine:    Apache    Tomcat/7.0.522014-03-05    10:57:51.253        INFO    45469    ---    [ost-startStop-1]    o.a.c.
c.C.[Tomcat].[localhost].[/]                            :    Initializing    Spring    embedde
d    WebApplicationContext
2014-03-05    10:57:51.253        INFO    45469    ---    [ost-startStop-1]    o.s.we
b.context.ContextLoader                                                :    Root    WebApplicationContext:
    initialization    completed    in    1358    ms
2014-03-05    10:57:51.698        INFO    45469    ---    [ost-startStop-1]    o.s.b.
c.e.ServletRegistrationBean                                :    Mapping    servlet:    &apos;dispatche
rServlet&apos;    to    [/]
2014-03-05    10:57:51.702        INFO    45469    ---    [ost-startStop-1]    o.s.b.
c.embedded.FilterRegistrationBean        :    Mapping    filter:    &apos;hiddenHttp
MethodFilter&apos;    to:    [/*]
</code></pre><p>输出的节点（items）如下：</p>
<ol>
<li>日期和时间    -    精确到毫秒，且易于排序。</li>
<li>日志级别    -          ERROR    ,          WARN    ,          INFO    ,          DEBUG        或          TRACE    。</li>
<li>Process    ID。</li>
<li>—    分隔符，用于区分实际日志信息开头。</li>
<li>线程名    -    包括在方括号中（控制台输出可能会被截断）。</li>
<li>日志名    -    通常是源class的类名（缩写）。</li>
<li>日志信息。<br>注    Logback没有     FATAL    级别，它会映射到     ERROR    。</li>
</ol>
<p>##控制台输出##</p>
<p>默认的日志配置会在写日志消息时将它们回显到控制台，级别为     ERROR    ,WARN    和     INFO    的消息会被记录。你可以在启动应用时，通过     –debug    标识开启控制台的DEBUG级别日志记录，也可以在application.properties    中指定     debug=true    。</p>
<pre><code>$    java    -jar    myapp.jar    --debug
</code></pre><p>当debug模式启用时，一系列核心loggers（内嵌容器，Hibernate，Spring    Boot<br>等）记录的日志会变多，但不会输出所有的信息。<br>相应地，你可以在启动应用时，通过     –trace    （或在     application.properties    设置     trace=true    ）启用”trace”模式，该模式能够追踪核心loggers（内嵌容器，Hibernate生成的schema，Spring全部的portfolio）的所有日志信息。    </p>
<p>##文件输出##</p>
<p>默认情况下，SpringBoot只会将日志记录到控制台，而不写进日志文件，如果需要，你可以设置     logging.file    或     logging.path    属性（例如     application.properties    ）。<br>下表展示如何组合使用     logging.*    ：</p>
<table>
<thead>
<tr>
<th style="text-align:center">logging.file</th>
<th style="text-align:center">logging.path</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(none)</td>
<td style="text-align:center">(none)</td>
<td style="text-align:center"></td>
<td style="text-align:center">只记录到控制台</td>
</tr>
<tr>
<td style="text-align:center">Specific    file</td>
<td style="text-align:center">(none)</td>
<td style="text-align:center">my.log</td>
<td style="text-align:center">写到特定的日志文件，名称可以是精确的位置或相对于当前目录</td>
</tr>
<tr>
<td style="text-align:center">(none)</td>
<td style="text-align:center">Specific directory</td>
<td style="text-align:center">/var/log</td>
<td style="text-align:center">写到特定目录下的     spring.log    里，名称可以是精确的位置或相对于当前目录</td>
</tr>
</tbody>
</table>
<p>日志文件每达到10M就会被分割，跟控制台一样，默认记录     ERROR    ,WARN    和     INFO    级别的信息。</p>
<p>##日志级别##</p>
<p>所有Spring    Boot支持的日志系统都可以在Spring          Environment    中设置级别（     application.properties    里也一样），设置格式为’logging.level.*=LEVEL’，其中     LEVEL    是     TRACE    ,          DEBUG    ,          INFO    ,          WARN    ,          ERROR    ,          FATAL    ,          OFF    之一：<br>以下是     application.properties    示例：</p>
<pre><code>logging.level.root=WARN
logging.level.org.springframework.web=DEBUG
logging.level.org.hibernate=ERROR
</code></pre><p>注    默认情况，Spring    Boot会重新映射Thymeleaf的     INFO    信息到     DEBUG    级别，这<br>能减少标准日志输出的噪声。查看LevelRemappingAppender可以按自己的配置设<br>置映射。</p>
]]></content>
      
        
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> log </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring WebMVC框架]]></title>
      <url>/2017/12/17/Spring_Web_MVC%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<p><strong>Spring WebMVC框架</strong></p>
<a id="more"></a>
<p>Spring    Web    MVC框架（通常简称为”SpringMVC”）是一个富“模型，视图，控制器”web框架，    允许用户创建特定的     @Controller    或     @RestController        beans来处理传入的HTTP请求，通过@RequestMapping注解可以将控制器中的方法映射到相应的HTTP请求。<br>示例：</p>
<pre><code>@RestController
@RequestMapping(value=&quot;/users&quot;)
public    class    MyRestController    {
                @RequestMapping(value=&quot;/{user}&quot;,    method=RequestMethod.GET)
                public    User    getUser(@PathVariable    Long    user)    {
                                //    ...
                }
                @RequestMapping(value=&quot;/{user}/customers&quot;,    method=RequestMet
hod.GET)
                List&lt;Customer&gt;    getUserCustomers(@PathVariable    Long    user)    {
                                //    ...
                }
                @RequestMapping(value=&quot;/{user}&quot;,    method=RequestMethod.DELETE
)
                public    User    deleteUser(@PathVariable    Long    user)    {
                                //    ...
                }
}
</code></pre><p>Spring    MVC是Spring框架的核心部分，详细信息可以参考reference<br>documentation，spring.io/guides也有一些可用的指导覆盖Spring    MVC。</p>
<h2 id="Spring-MVC自动配置"><a href="#Spring-MVC自动配置" class="headerlink" title="Spring    MVC自动配置"></a>Spring    MVC自动配置</h2><p>Spring    Boot为Spring    MVC提供的auto-configuration适用于大多数应用，并在<br>Spring默认功能上添加了以下特性：</p>
<ol>
<li>引入     ContentNegotiatingViewResolver    和     BeanNameViewResolver<br>beans。</li>
<li>对静态资源的支持，包括对WebJars的支持。</li>
<li>自动注册     Converter    ，     GenericConverter    ，     Formatter        beans。</li>
<li>对     HttpMessageConverters    的支持。</li>
<li>自动注册     MessageCodeResolver    。</li>
<li>对静态     index.html    的支持。</li>
<li>对自定义     Favicon    的支持。</li>
<li>自动使用     ConfigurableWebBindingInitializer        bean。</li>
</ol>
<p>如果保留Spring    Boot    MVC特性，你只需添加其他的MVC配置（拦截器，格式化处理器，视图控制器等）。你可以添加自己的     WebMvcConfigurerAdapter    类型的@Configuration类，而不需要注解@EnableWebMvc。如果希望使用自定义的     RequestMappingHandlerMapping    ，RequestMappingHandlerAdapter    ，或     ExceptionHandlerExceptionResolver，你可以声明一个WebMvcRegistrationsAdapter    实例提供这些组件。</p>
<p>如果想全面控制Spring    MVC，你可以添加自己的     @Configuration    ，并使用     @EnableWebMvc    注解。</p>
<p>##HttpMessageConverters##</p>
<p>Spring    MVC使用     HttpMessageConverter    接口转换HTTP请求和响应，合适的默认配置可以开箱即用，例如对象自动转换为JSON（使用Jackson库）或XML（如果Jackson XML扩展可用，否则使用JAXB），字符串默认使用     UTF-8    编码。<br>可以使用Spring    Boot的     HttpMessageConverters    类添加或自定义转换类：</p>
<pre><code>import    org.springframework.boot.autoconfigure.web.HttpMessageCon
verters;
import    org.springframework.context.annotation.*;
import    org.springframework.http.converter.*;
@Configuration
public    class    MyConfiguration    {
                @Bean
                public    HttpMessageConverters    customConverters()    {
                                HttpMessageConverter&lt;?&gt;    additional    =    ...
                                HttpMessageConverter&lt;?&gt;    another    =    ...
                                return    new    HttpMessageConverters(additional,    another);
                }
}
</code></pre><p>上下文中出现的所有     HttpMessageConverter        bean都将添加到converters列表，你可以通过这种方式覆盖默认的转换器列表（converters）。    </p>
<p>##自定义JSON序列化器和反序列化器##</p>
<p>如果使用Jackson序列化，反序列化JSON数据，你可能想编写自己的     JsonSerializer    和     JsonDeserializer    类。自定义序列化器（serializers）通常通过Module注册到Jackson，但Spring    Boot提供了     @JsonComponent    注解这一替代方式，它能轻松的将序列化器注册为Spring    Beans。</p>
<p>##MessageCodesResolver##</p>
<p>Spring    MVC有一个实现策略，用于从绑定的errors产生用来渲染错误信息的错误码：     MessageCodesResolver    。SpringBoot会自动为你创建该实现，只要设置spring.mvc.message-codes-resolver.format    属性为     PREFIX_ERROR_CODE    或     POSTFIX_ERROR_CODE    （具体查看     DefaultMessageCodesResolver.Format    枚举值）。</p>
<p>##静态内容##</p>
<p>默认情况下，Spring    Boot从classpath下的     /static    （     /public    ，     /resources    或     /META-INF/resources    ）文件夹，或从ServletContext    根目录提供静态内容。</p>
<p>这是通过Spring    MVC的     ResourceHttpRequestHandler    实现的，你可以自定义WebMvcConfigurerAdapter    并覆写addResourceHandlers    方法来改变该行为（加载静态文件）。</p>
<p>在单机web应用中，容器会启动默认的servlet，并用它加载     ServletContext    根目录下的内容以响应那些Spring不处理的请求。大多数情况下这都不会发生（除非你修改默认的MVC配置），因为Spring总能够通过     DispatcherServlet    处理这些请求。</p>
<p>你可以设置     spring.resources.staticLocations    属性自定义静态资源的位置（配置一系列目录位置代替默认的值），如果你这样做，默认的欢迎页面将从自定义位置加载，所以只要这些路径中的任何地方有一个     index.html    ，它都会成为应用的主页。</p>
<p>此外，除了上述标准的静态资源位置，有个例外情况是Webjars内容。任何在 /webjars/**    路径下的资源都将从jar文件中提供，只要它们以Webjars的格式<br>打包。</p>
<p>注    如果你的应用将被打包成jar，那就不要使用     src/main/webapp文件夹。尽管该文件夹是通常的标准格式，但它仅在打包成war的情况下起作用，在打包成jar时，多数构建工具都会默认忽略它。</p>
<p>Spring    Boot也支持SpringMVC提供的高级资源处理特性，可用于清除缓存的静态资源或对WebJar使用版本无感知的URLs。</p>
<p>如果想使用针对WebJars版本无感知的URLs（version    agnostic），只需要添<br>加     webjars-locator    依赖，然后声明你的Webjar。以jQuery为例，     “/webjars/jquery/dist/jquery.min.js”    实际<br>为     “/webjars/jquery/x.y.z/dist/jquery.min.js”    ，     x.y.z为Webjar的版<br>本。</p>
<p>注    如果使用JBoss，你需要声明     webjars-locator-jboss-vfs    依赖而不是     webjars-locator    ，否则所有的Webjars将解析为     404    。</p>
<p>以下的配置为所有的静态资源提供一种缓存清除（cache    busting）方案，实际上是<br>将内容hash添加到URLs中，比如     <link href="/css/spring-
2a2d595e6ed9a0b24f027f2b63b134d6.css">    ：</p>
<pre><code>spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
</code></pre><p>注    实现该功能的是     ResourceUrlEncodingFilter    ，它在模板运行期会重写资源链接，Thymeleaf，Velocity和FreeMarker会自动配置该filter，JSP需要手动配置。<br>其他模板引擎还没自动支持，不过你可以使用ResourceUrlProvider自定义模块宏或<br>帮助类。<br>当使用比如JavaScript模块加载器动态加载资源时，重命名文件是不行的，这也是提供其他策略并能结合使用的原因。下面是一个”fixed”策略，在URL中添加一个静态version字符串而不需要改变文件名：    </p>
<pre><code>spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
spring.resources.chain.strategy.fixed.enabled=true
spring.resources.chain.strategy.fixed.paths=/js/lib/
spring.resources.chain.strategy.fixed.version=v12
</code></pre><p>使用以上策略，JavaScript模块加载器加载     “/js/lib/“下的文件时会使用一个固定的版本策略     “/v12/js/lib/mymodule.js”    ，其他资源仍旧使用内容hash的方式     <link href="/css/spring-
2a2d595e6ed9a0b24f027f2b63b134d6.css">    。</p>
<p>查看ResourceProperties获取更多支持的选项。<br>注    该特性在一个专门的博文和Spring框架参考文档中有透彻描述。    </p>
<p>##ConfigurableWebBindingInitializer##</p>
<p>Spring    MVC使用     WebBindingInitializer    为每个特殊的请求初始化相应的WebDataBinder    ，如果你创建自己的     ConfigurableWebBindingInitializer @Bean    ，Spring    Boot会自动配置Spring    MVC使用它。</p>
<p>##模板引擎##</p>
<p>正如REST    web服务，你也可以使用Spring    MVC提供动态HTML内容。Spring    MVC<br>支持各种各样的模板技术，包括Velocity,    FreeMarker和JSPs，很多其他的模板引擎也提供它们自己的Spring    MVC集成。</p>
<p>Spring    Boot为以下的模板引擎提供自动配置支持：</p>
<ol>
<li>FreeMarker</li>
<li>Groovy</li>
<li>Thymeleaf</li>
<li>Velocity（1.4已不再支持）</li>
<li>Mustache</li>
<li>注：由于在内嵌servlet容器中使用JSPs存在一些已知的限制，所以建议尽量不使用它们。</li>
</ol>
<p>使用以上引擎中的任何一种，并采用默认配置，则模块会从src/main/resources/templates    自动加载。</p>
<p>注：IntelliJ    IDEA根据你运行应用的方式会对classpath进行不同的排序。<br>在IDE里通过main方法运行应用，跟从Maven，或Gradle，或打包好的jar中运行相比会导致不同的顺序，这可能导致SpringBoot不能从classpath下成功地找到模板。<br>如果遇到这个问题，你可以在IDE里重新对classpath进行排序，将模块的类和资源放到第一位。<br>或者，你可以配置模块的前缀为     classpath*:/templates/    ，这样会查找<br>classpath下的所有模板目录。</p>
<p>##错误处理##</p>
<p>Spring    Boot默认提供一个     /error    映射用来以合适的方式处理所有的错误，并将它注册为servlet容器中全局的    错误页面。<br>对于机器客户端（相对于浏览器而言，浏览器偏重于人的行为），它会产生一个具有详细错误，HTTP状态，异常信息的JSON响应。对于浏览器客户端，它会产生一个白色标签样式（whitelabel）的错误视图，该视图将以HTML格式显示同样的数据（可以添加一个解析为’error’的View来自定义它）。<br>为了完全替换默认的行为，你可以实现     ErrorController    ，并注册一个该类型的bean定义，或简单地添加一个     ErrorAttributes    类型的bean以使用现存的机制，只是替换显示的内容。</p>
<p>注          BasicErrorController    可以作为自定义     ErrorController    的基类，如果你想添加对新context    type的处理（默认处理     text/html    ），这会很有帮助。<br>你只需要继承     BasicErrorController，添加一个public方法，并注解带有     produces    属性的     @RequestMapping，然后创建该新类型的bean。<br>你也可以定义一个@ControllerAdvice去自定义某个特殊controller或exception类型的JSON文档：</p>
<pre><code>@ControllerAdvice(basePackageClasses    =    FooController.class)
public    class    FooControllerAdvice    extends    ResponseEntityException
Handler    {
                @ExceptionHandler(YourException.class)
                @ResponseBody
                ResponseEntity&lt;?&gt;    handleControllerException(HttpServletReque
st    request,    Throwable    ex)    {
                                HttpStatus    status    =    getStatus(request);
                                return    new    ResponseEntity&lt;&gt;(new    CustomErrorType(status.v
alue(),    ex.getMessage()),    status);
                }
                private    HttpStatus    getStatus(HttpServletRequest    request)    {
                                Integer    statusCode    =    (Integer)    request.getAttribute(&quot;jav
ax.servlet.error.status_code&quot;);
                                if    (statusCode    ==    null)    {
                                                return    HttpStatus.INTERNAL_SERVER_ERROR;
                                }
                                return    HttpStatus.valueOf(statusCode);
                }
}
</code></pre><p>在以上示例中，如果跟     FooController相同package的某个controller抛出     YourException    ，一个     CustomerErrorType    类型的POJO的json展示将代替     ErrorAttributes    展示。</p>
<p>自定义错误页面</p>
<p>如果想为某个给定的状态码展示一个自定义的HTML错误页面，你需要将文件添加到     /error    文件夹下。错误页面既可以是静态HTML（比如，任何静态资源文件夹下添加的），也可以是使用模板构建的，文件名必须是明确的状态码或一系列标签。</p>
<p>例如，映射     404    到一个静态HTML文件，你的目录结构可能如下：    </p>
<pre><code>src/
    +-    main/
            +-    java/
            |            +    &lt;source    code&gt;
            +-    resources/
                        +-    public/
                            +-    error/
                                |    +-    404.html
                            +-    &lt;other    public    assets&gt;    
</code></pre><p>使用FreeMarker模板映射所有     5xx    错误，你需要如下的目录结构：</p>
<pre><code>src/
    +-    main/
            +-    java/
            |            +    &lt;source    code&gt;
            +-    resources/
                    +-    templates/
                            +-    error/
                            |            +-    5xx.ftl
                            +-    &lt;other    templates&gt;
</code></pre><p>对于更复杂的映射，你可以添加实现     ErrorViewResolver接口的beans：</p>
<pre><code>public    class    MyErrorViewResolver    implements    ErrorViewResolver    {
                @Override
    public    ModelAndViewresolveErrorView(HttpServletRequest    requ
est,HttpStatus    status,Map&lt;String,    Object&gt;    model)    {
    //    Use    the    request    or    status    to    optionally    return    a    Mode
lAndView
                    return    ...
    }
}
</code></pre><p>你也可以使用Spring    MVC特性，比如@ExceptionHandler方法和@ControllerAdvice，ErrorController    将处理所有未处理的异常。</p>
<p>映射Spring    MVC以外的错误页面</p>
<p>对于不使用Spring    MVC的应用，你可以通过     ErrorPageRegistrar    接口直接注册     ErrorPages。<br>该抽象直接工作于底层内嵌servlet容器，即使你没有SpringMVC的DispatcherServlet    ，它们仍旧可以工作。    </p>
<pre><code>@Bean
public    ErrorPageRegistrar    errorPageRegistrar(){
                return    new    MyErrorPageRegistrar();
}
//    ...
private    static    class    MyErrorPageRegistrar    implements    ErrorPageRegistrar    {
                @Override
                public    void    registerErrorPages(ErrorPageRegistry    registry)    {
                                registry.addErrorPages(new    ErrorPage(HttpStatus.BAD_REQU
EST,    &quot;/400&quot;));
                }
}
</code></pre><p>注.如果你注册一个     ErrorPage    ，该页面需要被一个     Filter    处理（在一些非Spring    web框架中很常见，比如Jersey，Wicket），那么该     Filter    需要明确注册为一个     ERROR    分发器（dispatcher），例如：    </p>
<pre><code>@Bean
public    FilterRegistrationBean    myFilter()    {
                FilterRegistrationBean    registration    =    new    FilterRegistrationBean();
                registration.setFilter(new    MyFilter());
                ...
                registration.setDispatcherTypes(EnumSet.allOf(DispatcherType
.class));
                return    registration;
}
</code></pre><p>（默认的     FilterRegistrationBean    不包含     ERROR        dispatcher类型）。</p>
<p>WebSphere应用服务器的错误处理当部署到一个servlet容器时，Spring    Boot通过它的错误页面过滤器将带有错误状态的请求转发到恰当的错误页面。</p>
<p>request只有在response还没提交时才能转发（forwarded）到正确的错误页面，而WebSphere应用服务器8.0及后续版本默认情况会在servlet方法成功执行后提交response，你需要设置     com.ibm.ws.webcontainer.invokeFlushAfterService    属性为     false    来关闭该行为。    </p>
<p>##Spring HATEOAS##</p>
<p>如果正在开发基于超媒体的RESTful    API，你可能需要Spring    HATEOAS，而Spring<br>Boot会为其提供自动配置，这在大多数应用中都运作良好。</p>
<p>自动配置取代了     @EnableHypermediaSupport    ，只需注册一定数量的beans就能轻松构建基于超媒体的应用，这些beans包括     LinkDiscoverers    （客户端支持），     ObjectMapper    （用于将响应编排为想要的形式）。</p>
<p>ObjectMapper    可以根据     spring.jackson.*    属性或     Jackson2ObjectMapperBuilder        bean进行自定义。</p>
<p>通过注解     @EnableHypermediaSupport    ，你可以控制Spring    HATEOAS的配置，<br>但这会禁用上述     ObjectMapper    的自定义功能。</p>
<p>##CORS支持##</p>
<p>跨域资源共享（CORS）是一个大多数浏览器都实现了的W3C标准，它允许你以灵活的方式指定跨域请求如何被授权，而不是采用那些不安全，性能低的方式，比如IFRAME或JSONP。</p>
<p>从4.2版本开始，Spring MVC对CORS提供开箱即用的支持。不用添加任何特殊配置，只需要在Spring    Boot应用的controller方法上注解     @CrossOrigin    ，并添加CORS配置。<br>通过注册一个自定义     addCorsMappings(CorsRegistry)    方法的WebMvcConfigurer        bean可以指定全局CORS配置：</p>
<pre><code>@Configuration
public    class    MyConfiguration    {
            @Bean
            public    WebMvcConfigurer    corsConfigurer()    {
                                return    new    WebMvcConfigurerAdapter()    {
                                                @Override
            public    void    addCorsMappings(CorsRegistry    registry)    {
                                                                registry.addMapping(&quot;/api/**&quot;);
                                                }
                                };
            }
}
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> MVC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用CommandLineRunner或ApplicationRunner]]></title>
      <url>/2017/12/17/%E4%BD%BF%E7%94%A8CommandLineRunner%E6%88%96ApplicationRunner/</url>
      <content type="html"><![CDATA[<p><strong>使用CommandLineRunner或ApplicationRunner</strong></p>
<a id="more"></a>
<p>如果需要在     SpringApplication    启动后执行一些特殊的代码，你可以实<br>现     ApplicationRunner    或     CommandLineRunner    接口，这两个接口工作方式相<br>同，都只提供单一的     run    方法，该方法仅在     SpringApplication.run(…)    完成<br>之前调用。<br>     CommandLineRunner    接口能够访问string数组类型的应用参数，<br>而     ApplicationRunner    使用的是上面描述过的     ApplicationArguments    接口：</p>
<pre><code>import    org.springframework.boot.*
import    org.springframework.stereotype.*
@Component
public    class    MyBean    implements    CommandLineRunner    {
                public    void    run(String...    args)    {
                                //    Do    something...
                }
}
</code></pre><p>如果某些定义的     CommandLineRunner    或     ApplicationRunner        beans需要以特定<br>的顺序调用，你可以实现     <strong>org.springframework.core.Ordered</strong>    接口或使<br>用     <strong>org.springframework.core.annotation.Order</strong>    注解。</p>
]]></content>
      
        
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Application属性文件]]></title>
      <url>/2017/12/17/Application%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p><strong>Application属性文件</strong></p>
<a id="more"></a>
<p>SpringApplication    将从以下位置加载     application.properties    文件，并把<br>它们添加到Spring          Environment    中：</p>
<ol>
<li><p>当前目录下的     /config    子目录。</p>
</li>
<li><p>当前目录。</p>
</li>
<li><p>classpath下的     /config    包。</p>
</li>
<li><p>classpath根路径（root）。</p>
</li>
</ol>
<p>该列表是按优先级排序的（列表中位置高的路径下定义的属性将覆盖位置低的）。<br>注    你可以使用YAML（’.yml’）文件替代’.properties’。</p>
<p>如果不喜欢将     application.properties    作为配置文件名，你可以通过指<br>定     spring.config.name    环境属性来切换其他的名称，也可以使<br>用     spring.config.location    环境属性引用一个明确的路径（目录位置或文件路<br>径列表以逗号分割）。</p>
<pre><code>$    java    -jar    myproject.jar    --spring.config.name=myproject
或
$    java    -jar    myproject.jar    --spring.config.location=classpath:/de
fault.properties,classpath:/override.properties
</code></pre><p>注    在初期需要根据     spring.config.name    和     spring.config.location    决定加<br>载哪个文件，所以它们必须定义为environment属性（通常为OS    env，系统属性或<br>命令行参数）。</p>
<p>如果     spring.config.location    包含目录（相对于文件），那它们应该以     /    结尾<br>（在被加载前，     spring.config.name    关联的名称将被追加到后面，包括profile-<br>specific的文件名）。     spring.config.location    下定义的文件使用方法跟往常一<br>样，没有profile-specific变量支持的属性，将被profile-specific的属性覆盖。</p>
<p>不管     spring.config.location    配置什么值，默认总会按<br>照     classpath:,classpath:/config,file:,file:config/    的顺序进行搜索，优<br>先级由低到高，也就是     file:config/    获胜。<br>如果你指定自己的位置，它们会优先于所有的默认位置（locations），并使用相同的由低到高的优先级顺序。<br>那样，你就可以在     application.properties    为应用设置默认值，然后在运行的时候使<br>用不同的文件覆盖它，同时保留默认配置。</p>
<p>注    如果使用环境变量而不是系统属性，需要注意多数操作系统的key名称不允许以<br>句号分割（period-separated），但你可以使用下划线（underscores）代替（比<br>如，使用     SPRING_CONFIG_NAME    代替     spring.config.name    ）。<br>注    如果应用运行在容器中，那么JNDI属性（java:comp/env）或servlet上下文初始<br>化参数可以用来代替环境变量或系统属性，当然也可以使用环境变量或系统属性。</p>
]]></content>
      
        
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第三方配置]]></title>
      <url>/2017/12/17/%E7%AC%AC%E4%B8%89%E6%96%B9%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p><strong>第三方配置</strong></p>
<a id="more"></a>
<p>@ConfigurationProperties    不仅可以注解在类上，也可以注解在public @Bean    方法上，当你需要为不受控的第三方组件绑定属性时，该方法将非常有<br>用。为了从     Environment属性中配置一个bean，你需要使用@ConfigurationProperties    注解该bean：</p>
<pre><code>@ConfigurationProperties(prefix    =    &quot;foo&quot;)
@Bean
public    FooComponent    fooComponent()    {
                ...
}
</code></pre><p>和上面     ConnectionSettings    的示例方式相同，所有以foo为前缀的属性定义都会被映射到     FooComponent    上。</p>
<p>##Relaxed绑定##</p>
<p>Spring    Boot将     Environment    属性绑定到     @ConfigurationProperties        beans时会使用一些宽松的规则，所以     Environment属性名和bean属性名不需要精确匹配。常见的示例中有用的包括虚线分割（比如，     context-path    绑定到     contextPath    ），将environment属性转为大写字母（比如，     PORT    绑定     port    ）。<br>例如，给定以下     @ConfigurationProperties    类：</p>
<pre><code>@ConfigurationProperties(prefix=&quot;person&quot;)
public    class    OwnerProperties    {
                private    String    firstName;
                public    String    getFirstName()    {
                                return    this.firstName;
                }
                public    void    setFirstName(String    firstName)    {
                                this.firstName    =    firstName;
                }
}
</code></pre><p>下面的属性名都能使用：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">person.firstName</td>
<td style="text-align:center">标准驼峰规则</td>
</tr>
<tr>
<td style="text-align:center">person.first-name</td>
<td style="text-align:center">虚线表示，推荐用于     .properties    和     .yml文件中</td>
</tr>
<tr>
<td style="text-align:center">person.first_name</td>
<td style="text-align:center">下划线表示，用于     .properties    和     .yml    文件的可选格式</td>
</tr>
<tr>
<td style="text-align:center">PERSON_FIRST_NAME</td>
<td style="text-align:center">大写形式，使用系统环境变量时推荐</td>
</tr>
</tbody>
</table>
<p>##属性转换##</p>
<p>将外部应用配置绑定到     @ConfigurationProperties        beans时，Spring会尝试将属性强制转换为正确的类型。如果需要自定义类型转换器，你可以提供一个ConversionService        bean（bean    id为     conversionService    ），或自定义属性编辑器（通过     CustomEditorConfigurer        bean），或自定义     Converters    （bean定义时需要注解     @ConfigurationPropertiesBinding    ）。</p>
<p>注    由于该bean在应用程序生命周期的早期就需要使用，所以确保限制你的     ConversionService使用的依赖。通常，在创建时期任何你需要的依赖可能都<br>没完全初始化。        </p>
<p>##@ConfigurationProperties校验##</p>
<p>Spring    Boot将尝试校验外部配置，默认使用JSR-303（如果在classpath路径中），你只需要将JSR-303          javax.validation    约束注解添加到     @ConfigurationProperties    类上：</p>
<pre><code>@ConfigurationProperties(prefix=&quot;connection&quot;)
public    class    ConnectionProperties    {
                @NotNull
                private    InetAddress    remoteAddress;
                //    ...    getters    and    setters
}
</code></pre><p>为了校验内嵌属性的值，你需要使用     @Valid    注解关联的字段以触发它的校验，例<br>如：    </p>
<pre><code>@ConfigurationProperties(prefix=&quot;connection&quot;)
public    class    ConnectionProperties    {
                @NotNull
                @Valid
                private    RemoteAddress    remoteAddress;
                //    ...    getters    and    setters
                public    static    class    RemoteAddress    {
                                @NotEmpty
                                public    String    hostname;
                                //    ...    getters    and    setters
                }
}
</code></pre><p>你也可以通过创建一个叫做     configurationPropertiesValidator    的bean来添加自定义的Spring          Validator    。     @Bean    方法需要声明为     static    ，因为配置属性校验器在应用程序生命周期中创建的比较早，将     @Bean    方法声明为     static    允许该bean在创建时不需要实例化     @Configuration    类，从而避免了早期实例化（early    instantiation）的所有问题。相关的示例可以看这里。</p>
<p>注          spring-boot-actuator    模块包含一个暴露所有     @ConfigurationProperties        beans的端点（endpoint），通过浏览器打开     /configprops    进行浏览，或使用等效的JMX端点，具体参考Production    readyfeatures。    </p>
<h2 id="ConfigurationProperties-vs-Value"><a href="#ConfigurationProperties-vs-Value" class="headerlink" title="@ConfigurationProperties    vs.    @Value"></a>@ConfigurationProperties    vs.    @Value</h2><p>@Value    是Spring容器的一个核心特性，它没有提供跟type-safe    Configuration<br>Properties相同的特性。下面的表格总结了     @ConfigurationProperties    和     @Value    支持的特性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Relaxed绑定</td>
<td style="text-align:center">Yes</td>
<td>No</td>
</tr>
<tr>
<td style="text-align:center">Meta-data支持</td>
<td style="text-align:center">Yes</td>
<td>No</td>
</tr>
<tr>
<td style="text-align:center">SpEL表达式</td>
<td style="text-align:center">No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>如果你为自己的组件定义了一系列的配置keys，我们建议你将它们以@ConfigurationProperties    注解的POJO进行分组。<br>由于     @Value    不支持relaxed绑定，所以如果你使用环境变量提供属性值的话，它就不是很好的选择。最后，尽管     @Value    可以写     SpEL表达式，但这些表达式不会处理来自Application属性文件的属性。</p>
]]></content>
      
        
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> config </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring boot简介]]></title>
      <url>/2017/12/02/spring-boot%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p><strong>spring boot</strong></p>
<p>spring boot 为所有spring框架开发者提供一种更加易于理解，更加便捷高效的开发方式；<br>通过提供更为直观的spring平台和第三方依赖库，只需要极其少量的spring配置，便能部署运行spring boot应用。</p>
<a id="more"></a>
<p>1.环境要求</p>
<p>Spring Boot 2.0.0.BUILD-SNAPSHOT 需要 Java 8 以及 Spring Framework 5.0.2.RELEASE 或者以上版本.<br>当使用maven或者gradle构建spring boot时需要 Maven 3.2+ 或者 Gradle 4及其以上版本.</p>
<p>2.spring boot安装</p>
<p>2.1使用maven 构建spring boot应用</p>
<p>pom.xml配置:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;myproject&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

    &lt;!-- Inherit defaults from Spring Boot --&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.0.BUILD-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;!-- Add typical dependencies for a web application --&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;!-- Package as an executable jar --&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

    &lt;!-- Add Spring repositories --&gt;
    &lt;!-- (you don&apos;t need this if you are using a .RELEASE version) --&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-snapshots&lt;/id&gt;
            &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;
            &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;
        &lt;/repository&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-milestones&lt;/id&gt;
            &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;spring-snapshots&lt;/id&gt;
            &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;
        &lt;/pluginRepository&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;spring-milestones&lt;/id&gt;
            &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;
        &lt;/pluginRepository&gt;
    &lt;/pluginRepositories&gt;
&lt;/project&gt;
</code></pre><p>2.2安装Spring Boot CLI</p>
<p>The Spring Boot CLI (Command Line Interface)是一个用于快速建立spring原型的命令行工具.<br>通过它你能运行Groovy scripts,使用熟悉的类java语法。</p>
<p>使用CLI来运行spring boot不是必须的,但它是使spring应用运行起来的最快方法.</p>
<p>2.2.1 手动安装</p>
<p>你可以在spring 软件仓库下载Spring CLI</p>
<p><a href="https://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/2.0.0.BUILD-SNAPSHOT/spring-boot-cli-2.0.0.BUILD-SNAPSHOT-bin.zip" target="_blank" rel="external">spring-boot-cli-2.0.0.BUILD-SNAPSHOT-bin.zip</a></p>
<p><a href="https://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/2.0.0.BUILD-SNAPSHOT/spring-boot-cli-2.0.0.BUILD-SNAPSHOT-bin.tar.gz" target="_blank" rel="external">spring-boot-cli-2.0.0.BUILD-SNAPSHOT-bin.tar.gz</a></p>
<p>2.2.2 通过SDKMAN安装</p>
<p>SDKMAN!(The Software Development Kit Manager)可以用来管理不同版本的二进制sdks,包括 Groovy和Spring Boot CLI.<br>从<a href="http://sdkman.io/" target="_blank" rel="external">sdkman.io</a>获取SDKMAN!并且通过以下命令来安装Spring Boot</p>
<pre><code>$ sdk install springboot
$ spring --version
Spring Boot v2.0.0.BUILD-SNAPSHOT
</code></pre><p>上述的安装方式都会在本地建立一个名为dev的Spring实例,它指向你的安装路径,所以你每次重建Spring Boot时,<br>spring 都会更新到最新.</p>
<p>你能通过以下命令看到它是如何进行的:</p>
<p>$ sdk ls springboot</p>
<pre><code>================================================================================
Available Springboot Versions
================================================================================
&gt; + dev
* 2.0.0.BUILD-SNAPSHOT

================================================================================
+ - local version
* - installed
&gt; - currently in use
================================================================================    
</code></pre><p>3.开发你首个Spring Boot 应用</p>
<p>这个章节描述了如何区开发一个\”五脏俱全\”的Spring Boot \”Hello World!\”应用.<br>我们使用Maven来构建这个项目,因为大部分IDES都支持它.</p>
<p><a href="https://spring.io/" target="_blank" rel="external">spring.io</a>web网站包含很多”Getting Started”的spring boot教程,<br>如果你需要解决一些特定的问题,首先查看这里.</p>
<p>开始之前首先检查jdk版本和maven版本是否满足要求</p>
<p>java -version</p>
<p>mvn -v</p>
<p>pom.xml 配置如下:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;myproject&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.0.BUILD-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;!-- Additional lines to be added here... --&gt;

    &lt;!-- (you don&apos;t need this if you are using a .RELEASE version) --&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-snapshots&lt;/id&gt;
            &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;
            &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;
        &lt;/repository&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-milestones&lt;/id&gt;
            &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;spring-snapshots&lt;/id&gt;
            &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;
        &lt;/pluginRepository&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;spring-milestones&lt;/id&gt;
            &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;
        &lt;/pluginRepository&gt;
    &lt;/pluginRepositories&gt;
&lt;/project&gt;
</code></pre><p>3.2 Spring Boot提供了大量的”Starters”开始器使你能在classpath路径添加jars.<br>我们普通的例子应用已经在POM的父节点使用 spring-boot-starter-parent .</p>
<p>spring-boot-starter-parent是一个提供了众多有用Maven默认配置的特殊启动器.<br>它同样提供了dependency-management配置使你能够为一些dependencies依赖省略 version 配置.</p>
<p>但你开发其它特殊类型的应用时可能需要使用到其它启动器(Starters),例如,当我们开发一个web应用时,<br>我们添加spring-boot-starter-web 依赖.在那之前,我们可以通过以下命令查看依赖树:</p>
<p>mvn dependency:tree</p>
<p>通过mvn dependency:tree命令我们可以查看项目的依赖树结构,<br>你可以看到  spring-boot-starter-parent 本身没有提供其它依赖.<br>通过编辑pom.xml添加必要的依赖</p>
<dependencies><br>    <dependency><br>        <groupid>org.springframework.boot</groupid><br>        <artifactid>spring-boot-starter-web</artifactid><br>    </dependency><br></dependencies>

<p>如果你再次运行 mvn dependency:tree 命令,你就能看到一系列新添加的依赖,<br>包括tomcat 服务器以及spring boot本身.</p>
<p>3.3 代码编写</p>
<p>为了完成应用，我们首先需要创建一个java文件.<br>在src/main/java下创建Example.java文件并添加以下代码:</p>
<pre><code>import org.springframework.boot.*;
import org.springframework.boot.autoconfigure.*;
import org.springframework.web.bind.annotation.*;

@RestController
@EnableAutoConfiguration
public class Example {

    @RequestMapping(&quot;/&quot;)
    String home() {
        return &quot;Hello World!&quot;;
    }

    public static void main(String[] args) throws Exception {
        SpringApplication.run(Example.class, args);
    }

}
</code></pre><p>3.3.1 @RestController 和 @RequestMapping 注解</p>
]]></content>
      
        
        <tags>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[快速排序]]></title>
      <url>/2017/12/02/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><strong>快速排序</strong></p>
<p>堆排序是指利用堆这种数据结构所设计的一种排序算法.堆是一种特殊的二叉树,每个子节点的值总是小于(或大于)它的父节点,相应的分为最大堆或最小堆,<br>通过最大堆或最小堆不断输出堆顶元素,直到全部元素都已输出,得到的输出元素序列即为有序序列.</p>
<a id="more"></a>]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[堆排序]]></title>
      <url>/2017/12/01/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><strong>堆排序</strong></p>
<p>堆排序是指利用堆这种数据结构所设计的一种排序算法.堆是一种特殊的二叉树,每个子节点的值总是小于(或大于)它的父节点,相应的分为最大堆或最小堆,<br>通过最大堆或最小堆不断输出堆顶元素,直到全部元素都已输出,得到的输出元素序列即为有序序列.</p>
<a id="more"></a>
<pre><code>import java.util.Arrays;

public class HeapSort3 {

    public static void main(String[] args){

        int[] test = new int[]{8,11,3,6,23,14,18,7,55,34};

        System.out.println(&quot;初始数组:&quot; + Arrays.toString(test));

        HeapSort3.heapSort(test);

        System.out.println(Arrays.toString(test));

    }

    public static int leftChild(int child){


        return child * 2 + 1;

    }

    public static void precDown(int[] a,int i,int n){

        int child;

        int temp;
        for(temp = a[i];leftChild(i) &lt; n;i = child){

            child = leftChild(i);

            if(i != n - 1 &amp;&amp; a[child] &lt; a[child + 1]){
                child++;
            }
            if(a[i] &lt; a[child]){
                a[i] = a[child];
            }

        }
        a[i] = temp;
    }


    public static void swapReferences(int[] a,int index){

        int temp = a[0];
        a[0] = a[index];

        a[index] = temp;




    }

    public static void heapSort(int[] a){

        for(int i = a.length / 2;i &gt; 0;i--){

            precDown(a,i,a.length - 1);

        }
        System.out.println(&quot;max二叉堆构建完毕:&quot; + Arrays.toString(a));


        for(int k = a.length - 1;k &gt; 0;k--){

            swapReferences(a,k);
            precDown(a,0,k);


        }

    }


}
</code></pre><p><strong>最差时间复杂度:O(N*logN),平均时间复杂度O(N*logN),空间复杂度:O(1),不稳定算法</strong>        </p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[归并排序]]></title>
      <url>/2017/11/21/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><strong>归并排序</strong></p>
<p>将一个无序序列进行折半递归,直到得到单个元素的有序序列,然后递归的将折半后左右两边的有序序列依次进行合并,最终得到有序序列.</p>
<a id="more"></a>
<pre><code>import java.util.Arrays;

public class MergeSort {


    public static void main(String[] args){

        int[] a = new int[]{11,2,5,15,23,44,24,8};

        mergeSort(a);

        System.out.println(Arrays.toString(a));

    }

    private static  void mergeSort(int[] a,int[] tmpArray,int left,int right){

        if(left &lt; right){
            int center = (left + right) / 2;
            mergeSort(a,tmpArray,left,center);
            mergeSort(a,tmpArray,center + 1,right);
            merge(a,tmpArray,left,center + 1,right);
        }
        System.out.println(&quot;left:&quot; + left + &quot;,right:&quot; + right);

    }


    public static  void mergeSort(int[] a){
        int[] tmpArray = new int[a.length];
        mergeSort(a,tmpArray,0,a.length - 1);
    }


    private static  void merge(int[] a,int[] tmpArray,int leftPos,int rightPos,int rightEnd){

        System.out.println(&quot;leftPos:&quot; + leftPos + &quot;,rightPos:&quot; + rightPos + &quot;,rightEnd:&quot; + rightEnd);


        int leftEnd = rightPos - 1;
        int tmpPos = leftPos;
        int numElements = rightEnd - leftPos + 1;

        //Main loop

        while(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd){
            if(a[leftPos] &lt; a[rightPos]){
                tmpArray[tmpPos++] = a[leftPos++];
            }else{
                tmpArray[tmpPos++] = a[rightPos++];
            }
        }
        while(leftPos &lt;= leftEnd){
            tmpArray[tmpPos++] = a[leftPos++];
        }

        while(rightPos &lt;= rightEnd){
            tmpArray[tmpPos++] = a[rightPos++];
        }

        for(int i = 0;i &lt; numElements;i++,rightEnd--){
            a[rightEnd] = tmpArray[rightEnd];
        }

    }



}
</code></pre><p><strong>最差时间复杂度:O(N^2) 平均时间复杂度O(N*logN) 空间复杂度:O(N) 稳定算法</strong>    </p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[希尔排序]]></title>
      <url>/2017/11/20/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><strong>希尔排序</strong></p>
<p>希尔排序(ShellSort)的名称源于它的发明者Donald Shell.<br>它通过比较相距一定间隔(h[k])的元素来工作,各躺比较所用的距离随着算法的进行而减小(h[k-1]),直到只比较相邻元素的最后一趟排序为止,因此希尔排序也称为缩减增量排序.<br>希尔排序所使用的增量序列只要h[1]=1,任何增量序列都是可行的,但其时间复杂度会有所不同.<br><a id="more"></a></p>
<pre><code>import java.util.*;

public class Test {
    public static void main(String[] args){

        int[] test = new int[]{11,3,8,25,22};


        Test.shellSort(test);


    }


    /**
     * 希尔排序,使用ht=N/2 hk=h(k+1)/2的增量序列
     * @param a
     */
    public static void shellSort(int[] a){

        int hk;
        int j;
        for(hk = a.length / 2;hk &gt; 0 ;hk /= 2){



            for(int k = hk;k &lt; a.length;k++){
                int temp = a[k];
                for(j = k;j &gt;= hk &amp;&amp; a[j - hk] &gt; temp;j -= hk){
                    a[j] = a[j- hk];
                }
                a[j] = temp;
            }
        }
        System.out.println(Arrays.toString(a));
    }



}
</code></pre><p><strong>不稳定算法 空间复杂度O(1)</strong>    </p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[插入排序]]></title>
      <url>/2017/11/20/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><strong>插入排序</strong></p>
<p>插入排序由N-1趟排序组成,对于p=1到N-1趟,插入排序保证从位置0到位置p上的元素为已排序状态.</p>
<a id="more"></a>
<pre><code>import java.util.Arrays;

public class InsertSort2 {


    public static void main(String[] args){
        int[] a = new int[]{11,3,6,22,15};
        sort(a);
        System.out.println(Arrays.toString(a));
    }

    //插入排序：
    //将无序的元素插入到有序的元素序列中，插入后仍然有序
    public static void sort(int[] a){
        int k;
        for(int p = 1;p &lt; a.length;p++){
            int temp = a[p];
            for(k = p;k &gt; 0 &amp;&amp; a[k- 1] &gt; temp;k--){
                a[k] = a[k- 1];
            }
            a[k] = temp;
        }


    }


}
</code></pre><p><strong>最差时间复杂度:O(n^2) 平均时间复杂度O(n^2) 空间复杂度:O(1) 稳定算法</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[冒泡排序]]></title>
      <url>/2017/11/20/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><strong>冒泡排序</strong><br><a id="more"></a></p>
<pre><code>import java.util.Arrays;

public class MTest {

    //冒泡排序：
    //比较相邻元素，直到序列变为有序为止
    public static void main(String[] args){


        int[] a = new int[]{7,2,8,11,3,5,4};


        //int[] a = new int[]{1,2,3,4,5,6};

        for(int i = 0;i &lt; a.length - 1;i++){
            boolean flag =false;
            for(int k = 0;k &lt; a.length - 1 -i;k++){
                if(a[k] &gt; a[k + 1]){
                    int temp = a[k];
                    a[k] = a[k + 1];
                    a[k + 1] = temp;
                    flag = true;
                }

            }
            if(!flag){
                break;
            }
        }
        System.out.println(Arrays.toString(a));

    }


}
</code></pre><p><strong>每次循环对每对相邻元素依次进行比较,比较过后最后的元素也是最大的元素,重复n-1次即可得到有序序列</strong><br><strong>最差时间复杂度:O(n^2) 平均时间复杂度O(n^2) 空间复杂度:O(1) 稳定算法</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
