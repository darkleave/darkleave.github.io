<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[堆排序]]></title>
      <url>/2017/12/01/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><strong>堆排序</strong></p>
<p>堆排序是指利用堆这种数据结构所设计的一种排序算法.堆是一种特殊的二叉树,每个子节点的值总是小于(或大于)它的父节点,相应的分为最大堆或最小堆,<br>通过最大堆或最小堆不断输出堆顶元素,直到全部元素都已输出,得到的输出元素序列即为有序序列.</p>
<a id="more"></a>
<pre><code>import java.util.Arrays;

public class HeapSort3 {

    public static void main(String[] args){

        int[] test = new int[]{8,11,3,6,23,14,18,7,55,34};

        System.out.println(&quot;初始数组:&quot; + Arrays.toString(test));

        HeapSort3.heapSort(test);

        System.out.println(Arrays.toString(test));

    }

    public static int leftChild(int child){


        return child * 2 + 1;

    }

    public static void precDown(int[] a,int i,int n){

        int child;

        int temp;
        for(temp = a[i];leftChild(i) &lt; n;i = child){

            child = leftChild(i);

            if(i != n - 1 &amp;&amp; a[child] &lt; a[child + 1]){
                child++;
            }
            if(a[i] &lt; a[child]){
                a[i] = a[child];
            }

        }
        a[i] = temp;
    }


    public static void swapReferences(int[] a,int index){

        int temp = a[0];
        a[0] = a[index];

        a[index] = temp;




    }

    public static void heapSort(int[] a){

        for(int i = a.length / 2;i &gt; 0;i--){

            precDown(a,i,a.length - 1);

        }
        System.out.println(&quot;max二叉堆构建完毕:&quot; + Arrays.toString(a));


        for(int k = a.length - 1;k &gt; 0;k--){

            swapReferences(a,k);
            precDown(a,0,k);


        }

    }


}
</code></pre><p><strong>最差时间复杂度:O(N*logN),平均时间复杂度O(N*logN),空间复杂度:O(1),不稳定算法</strong>        </p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[归并排序]]></title>
      <url>/2017/11/21/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><strong>归并排序</strong></p>
<p>将一个无序序列进行折半递归,直到得到单个元素的有序序列,然后递归的将折半后左右两边的有序序列依次进行合并,最终得到有序序列.</p>
<a id="more"></a>
<pre><code>import java.util.Arrays;

public class MergeSort {


    public static void main(String[] args){

        int[] a = new int[]{11,2,5,15,23,44,24,8};

        mergeSort(a);

        System.out.println(Arrays.toString(a));

    }

    private static  void mergeSort(int[] a,int[] tmpArray,int left,int right){

        if(left &lt; right){
            int center = (left + right) / 2;
            mergeSort(a,tmpArray,left,center);
            mergeSort(a,tmpArray,center + 1,right);
            merge(a,tmpArray,left,center + 1,right);
        }
        System.out.println(&quot;left:&quot; + left + &quot;,right:&quot; + right);

    }


    public static  void mergeSort(int[] a){
        int[] tmpArray = new int[a.length];
        mergeSort(a,tmpArray,0,a.length - 1);
    }


    private static  void merge(int[] a,int[] tmpArray,int leftPos,int rightPos,int rightEnd){

        System.out.println(&quot;leftPos:&quot; + leftPos + &quot;,rightPos:&quot; + rightPos + &quot;,rightEnd:&quot; + rightEnd);


        int leftEnd = rightPos - 1;
        int tmpPos = leftPos;
        int numElements = rightEnd - leftPos + 1;

        //Main loop

        while(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd){
            if(a[leftPos] &lt; a[rightPos]){
                tmpArray[tmpPos++] = a[leftPos++];
            }else{
                tmpArray[tmpPos++] = a[rightPos++];
            }
        }
        while(leftPos &lt;= leftEnd){
            tmpArray[tmpPos++] = a[leftPos++];
        }

        while(rightPos &lt;= rightEnd){
            tmpArray[tmpPos++] = a[rightPos++];
        }

        for(int i = 0;i &lt; numElements;i++,rightEnd--){
            a[rightEnd] = tmpArray[rightEnd];
        }

    }



}
</code></pre><p><strong>最差时间复杂度:O(N^2) 平均时间复杂度O(N*logN) 空间复杂度:O(N) 稳定算法</strong>    </p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[希尔排序]]></title>
      <url>/2017/11/20/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><strong>希尔排序</strong></p>
<p>希尔排序(ShellSort)的名称源于它的发明者Donald Shell.<br>它通过比较相距一定间隔(h[k])的元素来工作,各躺比较所用的距离随着算法的进行而减小(h[k-1]),直到只比较相邻元素的最后一趟排序为止,因此希尔排序也称为缩减增量排序.<br>希尔排序所使用的增量序列只要h[1]=1,任何增量序列都是可行的,但其时间复杂度会有所不同.<br><a id="more"></a></p>
<pre><code>import java.util.*;

public class Test {
    public static void main(String[] args){

        int[] test = new int[]{11,3,8,25,22};


        Test.shellSort(test);


    }


    /**
     * 希尔排序,使用ht=N/2 hk=h(k+1)/2的增量序列
     * @param a
     */
    public static void shellSort(int[] a){

        int hk;
        int j;
        for(hk = a.length / 2;hk &gt; 0 ;hk /= 2){



            for(int k = hk;k &lt; a.length;k++){
                int temp = a[k];
                for(j = k;j &gt;= hk &amp;&amp; a[j - hk] &gt; temp;j -= hk){
                    a[j] = a[j- hk];
                }
                a[j] = temp;
            }
        }
        System.out.println(Arrays.toString(a));
    }



}
</code></pre><p><strong>不稳定算法 空间复杂度O(1)</strong>    </p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[插入排序]]></title>
      <url>/2017/11/20/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><strong>插入排序</strong></p>
<p>插入排序由N-1趟排序组成,对于p=1到N-1趟,插入排序保证从位置0到位置p上的元素为已排序状态.</p>
<a id="more"></a>
<pre><code>import java.util.Arrays;

public class InsertSort2 {


    public static void main(String[] args){
        int[] a = new int[]{11,3,6,22,15};
        sort(a);
        System.out.println(Arrays.toString(a));
    }

    //插入排序：
    //将无序的元素插入到有序的元素序列中，插入后仍然有序
    public static void sort(int[] a){
        int k;
        for(int p = 1;p &lt; a.length;p++){
            int temp = a[p];
            for(k = p;k &gt; 0 &amp;&amp; a[k- 1] &gt; temp;k--){
                a[k] = a[k- 1];
            }
            a[k] = temp;
        }


    }


}
</code></pre><p><strong>最差时间复杂度:O(n^2) 平均时间复杂度O(n^2) 空间复杂度:O(1) 稳定算法</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[冒泡排序]]></title>
      <url>/2017/11/20/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><strong>冒泡排序</strong><br><a id="more"></a></p>
<pre><code>import java.util.Arrays;

public class MTest {

    //冒泡排序：
    //比较相邻元素，直到序列变为有序为止
    public static void main(String[] args){


        int[] a = new int[]{7,2,8,11,3,5,4};


        //int[] a = new int[]{1,2,3,4,5,6};

        for(int i = 0;i &lt; a.length - 1;i++){
            boolean flag =false;
            for(int k = 0;k &lt; a.length - 1 -i;k++){
                if(a[k] &gt; a[k + 1]){
                    int temp = a[k];
                    a[k] = a[k + 1];
                    a[k + 1] = temp;
                    flag = true;
                }

            }
            if(!flag){
                break;
            }
        }
        System.out.println(Arrays.toString(a));

    }


}
</code></pre><p><strong>每次循环对每对相邻元素依次进行比较,比较过后最后的元素也是最大的元素,重复n-1次即可得到有序序列</strong><br><strong>最差时间复杂度:O(n^2) 平均时间复杂度O(n^2) 空间复杂度:O(1) 稳定算法</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
